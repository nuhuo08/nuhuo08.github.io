<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on XiaoWu</title>
    <link>https://nuhuo08.github.io/blog/</link>
    <description>Recent content in Blogs on XiaoWu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 09 Jan 2020 08:00:00 +0800</lastBuildDate>
    
	<atom:link href="https://nuhuo08.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ROS Navigation Stack</title>
      <link>https://nuhuo08.github.io/navigation-stack/</link>
      <pubDate>Thu, 09 Jan 2020 08:00:00 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/navigation-stack/</guid>
      <description>ROS系统结构 ROS Node ROS Node: 功能模块以Node的形式，处理某一特定的任务。      ROS Master: 记录所有现存的node，保证node之间的信息交流。parameter server运行在其中，实现参数与配置信息的共享。      ROS信息交互 单向通信：一个node发布topic，一个node订阅该topic      双向通信：一个node向另一个node发送信息并请求回复，使用service      查看ROS信息 rosnode list rostopic list rosservice list rostopic info /turtle1/cmd_vel rosmsg info geometry_msgs/Twist rqt_graph      ROS安装 ROS官网教程：ROS Tutorials
安装ROS基本功能包 由于Ubuntu默认软件源在国内访问速度较慢，建议切换到阿里云。
安装ROS：
sudo sh -c &amp;#39;. /etc/lsb-release &amp;amp;&amp;amp; echo &amp;#34;deb http://mirrors.ustc.edu.cn/ros/ubuntu/ `lsb_release -cs` main&amp;#34; &amp;gt; /etc/apt/sources.</description>
    </item>
    
    <item>
      <title>GMapping</title>
      <link>https://nuhuo08.github.io/gmapping/</link>
      <pubDate>Wed, 08 Jan 2020 08:00:00 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/gmapping/</guid>
      <description>基本理论 SLAM问题的分解 \[ \begin{aligned} p(x_{1:t},m|u_{1:t},z_{1:t}) &amp;= p(x_{1:t}|u_{1:t},z_{1:t}) p(m|u_{1:t},z_{1:t})\\ &amp;= p(x_{1:t}|u_{1:t},z_{1:t}) p(m|z_{1:t}) \end{aligned} \]
将SLAM问题分解为：机器人的定位；基于已知机器人位姿的构图。
Fast-SLAM 根据贝叶斯公式，可以将机器人位姿的估计，转换成一个增量估计问题。
\[ \begin{aligned} p(x_{1:t}|u_{1:t},z_{1:t}) &amp;= \eta p(z_t|x_{1:t},u_{1:t},z_{1:t-1}) p(x_{1:t}|z_{1:t-1},u_{1,t})\\ &amp;= \eta p(z_t|x_t) p(x_{1:t}|z_{1:t-1},u_{1:t})\\ &amp;= \eta p(z_t|x_t) p(x_t|x_{1:t-1},z_{1:t-1},u_{1:t}) p(x_{1:t-1}|z_{1:t-1},u_{1:t})\\ &amp;= \eta p(z_t|x_t) p(x_t|x_{t-1},u_{1:t}) p(x_{1:t-1}|z_{1:t-1},u_{1:t-1}) \end{aligned} \]
其中，\(p(x_{1:t-1}|z_{1:t-1},u_{1:t-1})\)通过粒子群来表示； \(p(x_t|x_{t-1},u_{1:t})\)对每个粒子进行运动学模型的传播； \(p(z_t|x_t)\)根据观测模型计算权重。
数据结构相关 Map template &amp;lt;class Cell, const bool debug=false&amp;gt; class Array2D{}; template &amp;lt;class Cell&amp;gt; class HierarchicalArray2D: public Array2D&amp;lt;autoptr&amp;lt; Array2D&amp;lt;Cell&amp;gt; &amp;gt; &amp;gt;{}; template &amp;lt;class Cell, class Storage, const bool isClass=true&amp;gt; class Map{}; typedef Map&amp;lt;PointAccumulator,HierarchicalArray2D&amp;lt;PointAccumulator&amp;gt; &amp;gt; ScanMatcherMap;  Array2D是一个二维数组，HierarchicalArray2D是一个Array2D的二维数组。 相当于将地图先分割成分辨率比较低的网格，只有当粒子运动到该网格时，才真正分配这个网格的内存。 网格的内存对应着分辨率高的真实的地图，用PointAccumulator来进行计数，记录激光是否通过该点，从而判断改点的状态：占据、空闲、未知。</description>
    </item>
    
    <item>
      <title>SLAM for Dummies</title>
      <link>https://nuhuo08.github.io/slam-for-dummies/</link>
      <pubDate>Tue, 07 Jan 2020 08:00:00 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/slam-for-dummies/</guid>
      <description>TO BE CONTINUED
https://zhuanlan.zhihu.com/p/32937247
观测方程 \[ \underbrace{\begin{pmatrix} r_1 \\ \theta_1 \\ r_2 \\ \theta_2 \\ \vdots \\ r_n \\ \theta_n \end{pmatrix}}_Z = \underbrace{\begin{bmatrix} A_1 &amp;B_1 &amp;C_1 &amp;-A_1 &amp;-B_1 \\ D_1 &amp;E_1 &amp;F_1 &amp;-D_1 &amp;-E_1 \\ A_2 &amp;B_2 &amp;C_2 &amp; &amp; &amp;-A_2 &amp;-B_2 \\ D_2 &amp;E_2 &amp;F_2 &amp; &amp; &amp;-D_2 &amp;-E_2 \\ &amp;\vdots &amp; &amp; &amp; &amp; &amp; &amp; \ddots \\ A_n &amp;B_n &amp;C_n &amp; &amp; &amp; &amp; &amp; &amp;-A_n &amp;-B_n \\ D_n &amp;E_n &amp;F_n &amp; &amp; &amp; &amp; &amp; &amp;-D_n &amp;-E_n \\ \end{bmatrix}}_H \underbrace{\begin{pmatrix} x_r \\ y_r \\ \theta_r \\ x_1 \\ y_1 \\ x_2 \\ y_2 \\ \vdots \\ x_n \\ y_n \end{pmatrix}}_X \\[2mm] R = \begin{pmatrix} r_c &amp; \\ &amp;r_d \end{pmatrix} \]</description>
    </item>
    
    <item>
      <title>Non-Linear</title>
      <link>https://nuhuo08.github.io/non-linear/</link>
      <pubDate>Mon, 06 Jan 2020 08:00:00 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/non-linear/</guid>
      <description>g2o g2o在ORB-SLAM2中的用法 Ceres http://ceres-solver.org/nnls_modeling.html
对于以下代价函数：
\[ \frac{1}{2} \sum_i \rho_i(\parallel f_i(x_{i1}, x_{i2}, \cdots, x_{ik}) \parallel ^2) \]
在Ceres中，\(\rho\)为loss function，用于减弱外点的影响；\(f\)为cost function，定义了残差的计算方式；\((x_{i1}, x_{i2}, \cdots, x_{ik})\)为parameter block，定义了需要估计的变量；\(\rho_i(\parallel f_i(x_{i1}, x_{i2}, \cdots, x_{ik}) \parallel ^2)\)为residual block，定义了一个残差块。
AddResidualBlock problem.AddResidualBlock(costfunction, lossfunction, x1, x2 ... xn)
其中，\(x_1, x_2, \cdots x_n\)要与costfunction中的变量维数要对应起来。
costfunction有两种典型的定义方式：
 自己实现残差、雅可比  templateclass SizedCostFunction : public CostFunction { public: virtual bool Evaluate(double const* const* parameters, double* residuals, double** jacobians) const = 0; }; 这种情况下，需要指定残差维数、参数块维数，并自己实现Evaluate()，计算cost和jacobian。
自己实现残差即可  template class AutoDiffCostFunction : public SizedCostFunction{ public: explicit AutoDiffCostFunction(CostFunctor* functor); // Ignore the template parameter kNumResiduals and use // num_residuals instead.</description>
    </item>
    
    <item>
      <title>VINS-MONO</title>
      <link>https://nuhuo08.github.io/vins-mono/</link>
      <pubDate>Sun, 05 Jan 2020 08:00:00 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/vins-mono/</guid>
      <description>代码流程图      动态方程 预积分公式推导 \(b_k^a\)和\(b_k^g\)作为随机游走噪声，在推导\(k \sim k+1\)时认为是常数！不像\(w\)和\(a\)，要添加\(n_k^g\)和\(n_k^a\)噪声进去
\[ \omega=\frac{1}{2}( (\omega^{b_k}+n_k^g-b_k^g) + (\omega^{b_{k+1}}+n_{k+1}^g-b_k^g) ) \\[2mm] q_{b_ib_{k+1}}=q_{b_ib_k}\otimes\begin{bmatrix}1 \\ \frac{1}{2}\omega\delta{t}\end{bmatrix} \\[2mm] a=\frac{1}{2}( q_{b_ib_k}(a^{b_k}+n_k^a-b_k^a) + q_{b_ib_{k+1}}(a^{b_{k+1}}+n_{k+1}^a-b_k^a) ) \\[2mm] \beta_{b_ib_{k+1}}=\beta_{b_ib_k}+a\delta{t} \\[2mm] \alpha_{b_ib_{k+1}}=\alpha_{b_ib_k}+\beta_{b_ib_k}\delta{t}+\frac{1}{2}a\delta{t}^2 \\[2mm] b_{k+1}^a=b_k^a+n_{b_k^a}\delta{t} \\[2mm] b_{k+1}^g=b_k^g+n_{b_k^g}\delta{t} \\[2mm] \]
写成矩阵形式：
\[ \begin{bmatrix}\alpha_{b_ib_{k+1}} \\ \theta_{b_ib_{k+1}} \\ \beta_{b_ib_{k+1}} \\ b_{k+1}^a \\ b_{k+1}^g\end{bmatrix} =F*\begin{bmatrix}\alpha_{b_ib_{k}} \\ \theta_{b_ib_{k}} \\ \beta_{b_ib_{k}} \\ b_{k}^a \\ b_{k}^g\end{bmatrix} +G*\begin{bmatrix}n_k^a \\ n_k^g \\ n_{k+1}^a \\ n_{k+1}^g \\ n_{k}^a \\ n_{k}^g \end{bmatrix} \]</description>
    </item>
    
    <item>
      <title>ORB-SLAM2</title>
      <link>https://nuhuo08.github.io/orb-slam2/</link>
      <pubDate>Sat, 04 Jan 2020 08:00:00 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/orb-slam2/</guid>
      <description>Tracking Initialization SearchForInitialization --&amp;gt; Initialize(RANSAC) --&amp;gt; GlobalBundleAdjustemnt --&amp;gt; ComputeSceneMedianDepth
SearchForInitialization:
GetFeaturesInArea --&amp;gt; DescriptorDistance --&amp;gt; ComputeThreeMaxima
ORB特征
Oriented FAST关键点：
 比较像素点周围圆上的像素间亮度的差异 非极大值抑制，在一定区域内仅保留响应极大值的角点，避免太集中 对角点计算Harris响应值，仅保留前N个具有最大响应值的角点 构建金字塔，在金字塔每一层检测角点。实现尺度不变 灰度质心法，连接图像块的几何中心与质心。实现旋转不变  BRIEF描述子：
 随机选点并比较灰度，组成128维的二进制数组 使用Hamming distance作为度量，即不同位数的个数  F矩阵
https://zhuanlan.zhihu.com/p/61614421
在求解F和H矩阵之前，应该首先进行特征点归一化，保证坐标均值为0，一阶绝对矩为1。(MVG P67，归一化才能消除坐标变换的影响)
设\(p1\)，\(p2\)为像素坐标，可知：
\[ p_2 = K (RP + t) \\[2mm] p_1 = KP \]
从上述\(p1\)，\(p2\)的关系式出发，导出：
\[ (K^{-1} p_2)^T t^{\wedge} K^{-1} p_2 = 0 = p_2^T K^{-T} t^{\wedge} R K^{-1} p_1 = p_2^T F p_1 \]
一对匹配的像素点可以写1个方程，考虑到尺度等价性，使用八点法即可求解\(F\)矩阵。</description>
    </item>
    
    <item>
      <title>MSCKF</title>
      <link>https://nuhuo08.github.io/msckf/</link>
      <pubDate>Fri, 03 Jan 2020 08:00:00 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/msckf/</guid>
      <description>QR分解 \[ A_{2m \times 3} = Q_{2m \times 2m}R_{2m \times 3} = \begin{bmatrix} B_{2m \times 3} &amp;C_{2m \times (2m - 3)} \end{bmatrix} \begin{bmatrix} D_{3 \times 3} \\ 0_{(2m - 3) \times 3} \end{bmatrix} \]
其中，\(Q\) 为正交矩阵，每一列代表一个基向量，与除了自身以外的其他基向量的点积都为0。Where \(B\) and \(C\) are unitary matrices whose columns form bases for the range and nullspace of \(A\).
\[ {C^T}_{(2m-3) * 2m} A_{2m \times 3} = \begin{bmatrix} 0_{(2m-3) \times 3} &amp;I_{(2m-3) \times (2m - 3)} \end{bmatrix} \begin{bmatrix} D_{3 \times 3} \\ 0_{(2m - 3) \times 3} \end{bmatrix} = 0_{(2m-3) \times 3} \]</description>
    </item>
    
    <item>
      <title>AMCL</title>
      <link>https://nuhuo08.github.io/amcl/</link>
      <pubDate>Thu, 02 Jan 2020 08:00:00 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/amcl/</guid>
      <description>ROS-AMCL      粒子聚类 对外输出的机器人状态不应该是某一个最好的粒子，因为很有可能某些粒子的值都非常接近，可能会引起频繁的粒子切换，导致输出的结果来回跳变。
基于此考虑， 应该对相似的粒子进行聚类。将最好的那一簇粒子的统计状态作为输出的机器人状态。
KD-Tree 当涉及到距离查找时，作为算法工程师，我们应该首先想到KD-Tree。树的叶子节点是每一个粒子，而非叶子节点则保存的是该节点的分叉判断的标准，小于此分叉判断标准的在左边，大于此分叉标准的在右边。
查询的基本思路：首先通过二叉树搜索（比较待查询节点和分裂节点的分裂维的值，小于等于就进入左子树分支，等于就进入右子树分支直到叶子结点），顺着“搜索路径”很快能找到最近邻的近似点，也就是与待查询点处于同一个子空间的叶子结点；然后再回溯搜索路径，并判断搜索路径上的结点的其他子结点空间中是否可能有距离查询点更近的数据点，如果有可能，则需要跳到其他子结点空间中去搜索（将其他子结点加入到搜索路径）。重复这个过程直到搜索路径为空。
     聚类 循环遍历每一个叶子节点，在叶子节点周围的 +-1 范围内的粒子都归为一类。例如在AMCL中，每个粒子周围27个粒子若有相连的，就将它们全部连成一片，形成一簇粒子。
粒子滤波改进 为了防止机器人被绑架，出现粒子收敛于某一错误的地方，需要进行粒子滤波的改良。
粒子注入 我们来考虑如下的式子：
\[ x_1 = x + 0.1(y-x) \\[2mm] x_2 = x + 0.9(y-x) \]
对于上面两个式子，展开以后我们可以发现：\(x_1\) 主要受到 \(x\) 的影响，而 \(x_2\) 主要受到 \(y\) 的影响。若粒子收敛于正确的状态，则 \(y\) 是准确的，\(x_2\) 将会比 \(x_1\) 更大，此时不需要注入粒子。若粒子收敛于错误的地方，则 \(y\) 不准确，此时 \(x_1\) 受到 \(y\) 的影响较小，\(x_1\) 更准确，此时便需要注入粒子。
而这正是AMCL里面slow和fast参数产生的效果。
KLD自适应 KLD的计算属于数理统计的知识，可参考论文1。这里进行直观的解释。
例如，某一粒子权值很大。当我们进行100次采样，可能都采样到的是同一个粒子，此时粒子的个数始终保持为1。而KLD计算出来的需要采样的次数，是粒子个数的函数。因此，当粒子数保持为1时，KLD计算出来的次数为某一定值，而采样次数持续在增加，到某一时间点，便超过了需要的采样次数。
而当粒子权值都接近时，假设我们采样了100次，每次采样出来的粒子都不同，此时粒子的个数一直增长到100。此时的KLD也随着粒子的个数增长到一个比较大的值。采样的次数虽然持续增加，但是始终超过不了KDL计算出来的次数。此种情况下采样仍将继续。
距离计算 计算每个粒子的权重时，我们需要计算观测到的障碍物与地图中的障碍物的距离差异。差异越大，权值越小。当某次观测的障碍物全部与地图上的障碍物匹配上了，则差异为0，权值极大。因此，在地图的初始阶段，我们需要计算地图上任一点位置到最近障碍物的距离。这就是似然场模型。
直接计算 遍历每一个点，计算每一个点到每个障碍物的距离并取最小值。此方法进行了重复计算，效率较低。
高效算法 从障碍物出发，向外膨胀一个单位。当所有障碍物膨胀完以后，从膨胀出来的地方出发，继续向外膨胀一个单位。此方法没有冗余计算，且实现的代码简洁。</description>
    </item>
    
    <item>
      <title>Hugo Website</title>
      <link>https://nuhuo08.github.io/hugo-website/</link>
      <pubDate>Wed, 01 Jan 2020 08:00:00 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/hugo-website/</guid>
      <description>申请Github账号 Github私人博客仓库 新建Hugo_Blogs仓库，此仓库保存个人的markdown源文件等。可设置为private仓库。
Github Pages 新建username.github.io的仓库，此仓库保存Hugo生成出来的html文件等。https://username.github.io/即为最终的个人博客地址。必须设置为public仓库。
安装Hugo Hugo Tutorial
Binary Package
新建私人博客文件夹 创建网站文件夹 新建网站文件夹，并用hugo生成基本网站文件
mkdir MyWebsite &amp;amp;&amp;amp; cd MyWebsite hugo new site . 链接Github私人博客仓库 添加git源，保存私人的markdown源文件
git init git remote add origin https://github.com/username/Hugo_Blogs.git 添加并使用新的theme git submodule add https://github.com/nuhuo08/uswds-hugo-theme.git themes/uswds-hugo-theme git submodule update --remote --merge cp themes/uswds-hugo-theme/exampleSite/config.yaml . 编辑网页 链接Github Pages 为了能够使用git submodule，需要先在仓库里添加点文件，之后再把它删掉。
mkdir public &amp;amp;&amp;amp; cd public &amp;amp;&amp;amp; touch abc git remote add origin https://github.com/username/username.github.io.git git add . git commit -m &amp;quot;abc&amp;quot; git push orign master cd .</description>
    </item>
    
  </channel>
</rss>