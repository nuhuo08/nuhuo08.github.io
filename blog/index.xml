<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on XiaoWu</title>
    <link>https://nuhuo08.github.io/blog/</link>
    <description>Recent content in Blogs on XiaoWu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 02 Jan 2020 08:00:00 +0800</lastBuildDate>
    
	<atom:link href="https://nuhuo08.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>AMCL Localization</title>
      <link>https://nuhuo08.github.io/amcl/</link>
      <pubDate>Thu, 02 Jan 2020 08:00:00 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/amcl/</guid>
      <description>粒子聚类 对外输出的机器人状态不应该是某一个最好的粒子，因为很有可能某些粒子的值都非常接近，可能会引起频繁的粒子切换，导致输出的结果来回跳变。
基于此考虑， 应该对相似的粒子进行聚类。将最好的那一簇粒子的统计状态作为输出的机器人状态。
KD-Tree 当涉及到距离查找时，作为算法工程师，我们应该首先想到KD-Tree。树的叶子节点是每一个粒子，而非叶子节点则保存的是该节点的分叉判断的标准，小于此分叉判断标准的在左边，大于此分叉标准的在右边。
查询的基本思路：首先通过二叉树搜索（比较待查询节点和分裂节点的分裂维的值，小于等于就进入左子树分支，等于就进入右子树分支直到叶子结点），顺着“搜索路径”很快能找到最近邻的近似点，也就是与待查询点处于同一个子空间的叶子结点；然后再回溯搜索路径，并判断搜索路径上的结点的其他子结点空间中是否可能有距离查询点更近的数据点，如果有可能，则需要跳到其他子结点空间中去搜索（将其他子结点加入到搜索路径）。重复这个过程直到搜索路径为空。
     聚类 循环遍历每一个叶子节点，在叶子节点周围的 +-1 范围内的粒子都归为一类。例如在AMCL中，每个粒子周围27个粒子若有相连的，就将它们全部连成一片，形成一簇粒子。
粒子滤波改进 为了防止机器人被绑架，出现粒子收敛于某一错误的地方，需要进行粒子滤波的改良。
粒子注入 我们来考虑如下的式子：
$$ x_1 = x + 0.1(y-x) $$ $$ x_2 = x + 0.9(y-x) $$
对于上面两个式子，展开以后我们可以发现：$x_1$ 主要受到 $x$ 的影响，而 $x_2$ 主要受到 $y$ 的影响。若粒子收敛于正确的状态，则 $y$ 是准确的，$x_2$ 将会比 $x_1$ 更大，此时不需要注入粒子。若粒子收敛于错误的地方，则 $y$ 不准确，此时 $x_1$ 受到 $y$ 的影响较小，$x_1$ 更准确，此时便需要注入粒子。
而这正是AMCL里面slow和fast参数产生的效果。
KLD自适应 KLD的计算属于数理统计的知识，可参考论文1。这里进行直观的解释。
例如，某一粒子权值很大。当我们进行100次采样，可能都采样到的是同一个粒子，此时粒子的个数始终保持为1。而KLD计算出来的需要采样的次数，是粒子个数的函数。因此，当粒子数保持为1时，KLD计算出来的次数为某一定值，而采样次数持续在增加，到某一时间点，便超过了需要的采样次数。
而当粒子权值都接近时，假设我们采样了100次，每次采样出来的粒子都不同，此时粒子的个数一直增长到100。此时的KLD也随着粒子的个数增长到一个比较大的值。采样的次数虽然持续增加，但是始终超过不了KDL计算出来的次数。此种情况下采样仍将继续。
距离计算 计算每个粒子的权重时，我们需要计算观测到的障碍物与地图中的障碍物的距离差异。差异越大，权值越小。当某次观测的障碍物全部与地图上的障碍物匹配上了，则差异为0，权值极大。因此，在地图的初始阶段，我们需要计算地图上任一点位置到最近障碍物的距离。这就是似然场模型。
直接计算 遍历每一个点，计算每一个点到每个障碍物的距离并取最小值。此方法进行了重复计算，效率较低。
高效算法 从障碍物出发，向外膨胀一个单位。当所有障碍物膨胀完以后，从膨胀出来的地方出发，继续向外膨胀一个单位。此方法没有冗余计算，且实现的代码简洁。
AMCL参数解读 min_particles / max_particles / kld_err / kld_z : 用来限制粒子数量</description>
    </item>
    
    <item>
      <title>Hugo搭建个人网站</title>
      <link>https://nuhuo08.github.io/hugo-website/</link>
      <pubDate>Wed, 01 Jan 2020 08:00:00 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/hugo-website/</guid>
      <description>申请Github账号 Github私人博客仓库 新建Hugo_Blogs仓库，此仓库保存个人的markdown源文件等。可设置为private仓库。
Github Pages 新建username.github.io的仓库，此仓库保存Hugo生成出来的html文件等。https://username.github.io/即为最终的个人博客地址。必须设置为public仓库。
安装Hugo Hugo Tutorial
Binary Package
新建私人博客文件夹 创建网站文件夹 新建网站文件夹，并用hugo生成基本网站文件
mkdir MyWebsite &amp;amp;&amp;amp; cd MyWebsite hugo new site . 链接Github私人博客仓库 添加git源，保存私人的markdown源文件
git init git remote add origin https://github.com/username/Hugo_Blogs.git 添加并使用新的theme git submodule add https://github.com/nuhuo08/uswds-hugo-theme.git themes/uswds-hugo-theme git submodule update --remote --merge cp themes/uswds-hugo-theme/exampleSite/config.yaml . 编辑网页 链接Github Pages 为了能够使用git submodule，需要先在仓库里添加点文件，之后再把它删掉。
mkdir public &amp;amp;&amp;amp; cd public &amp;amp;&amp;amp; touch abc git remote add origin https://github.com/username/username.github.io.git git add . git commit -m &amp;quot;abc&amp;quot; git push orign master cd .</description>
    </item>
    
  </channel>
</rss>