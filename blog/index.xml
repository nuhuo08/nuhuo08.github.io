<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on XiaoWu</title>
    <link>https://nuhuo08.github.io/blog/</link>
    <description>Recent content in Blogs on XiaoWu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 15 Mar 2020 13:33:44 +0800</lastBuildDate>
    
	<atom:link href="https://nuhuo08.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>move_base 模块</title>
      <link>https://nuhuo08.github.io/move_base/</link>
      <pubDate>Sun, 15 Mar 2020 13:33:44 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/move_base/</guid>
      <description>整体模块     odometry source: 里程计用来提供高频率的概略初始位姿； sensor sources: 机器人或无人车中，包含大量可用于定位的传感器：相机、激光、毫米波雷达等； map_server: 用激光SLAM手段，如 LOAM、GMapping 建立高精度地图； amcl: 结合传感器与高精度地图，实现 蒙特卡洛定位。  规划和控制     Global Planner
 global_planner: 可用来取代过时的navfn。 使用A*或Dijkstra算法进行全局路径规划。 carrot_planner: 简单的测试算法。  Local Planner
 base_local_planner: 实现Dynamic Window Approach(DWA) and Trajectory Rollout两种算法。其中DWA算法被dwa_local_planner取代。 eband_local_planner: Implements the Elastic Band method on the SE2 manifold teb_local_planner: Implements the Timed-Elastic-Band method for online trajectory optimization mpc_local_planner: Provides several model predictive control approaches embedded in the SE2 manifold  Recovery Behavior</description>
    </item>
    
    <item>
      <title>Kd Tree</title>
      <link>https://nuhuo08.github.io/kd-tree/</link>
      <pubDate>Fri, 13 Mar 2020 11:53:57 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/kd-tree/</guid>
      <description>建立KD-Tree  选取方差最大的特征作为分割特征； 选择该特征的中位数作为分割点； 将数据集中该特征小于中位数的传递给根节点的左节点，大于中位数的传递给根节点的右节点； 递归执行步骤1-3，直到所有数据都被建立到KD Tree的节点上为止。     查找元素  从根节点开始，根据目标在分割特征中是否小于或大于当前节点，向左或向右移动； 一旦算法到达叶节点，它就将节点点保存为“当前最佳”； 回溯，即从叶节点再返回到根节点； 如果当前节点比当前最佳节点更接近，那么它就成为当前最好的； 如果目标距离当前节点的父节点所在的将数据集分割为两份的超平面的距离更接近，说明当前节点的兄弟节点所在的子树有可能包含更近的点。 因此需要对这个兄弟节点递归执行1-4步。  使用范例 AMCL 定位中，会使用大量的粒子描述状态的统计信息。为了防止最优粒子频繁切换带来的定位结果抖动，需要对粒子进行分组。 将临近的粒子分为一组，就需要使用KD-Tree进行查找。请参考 粒子聚类。
建立KD-Tree时，不一定要选择方差最大的特征作为分割特征，也不一定要选择该特征的中位数作为分割点。 进行这两个步骤的统计可能会消耗大量的计算，因此实际实现中，也可以随机选择某个数作为分割点。</description>
    </item>
    
    <item>
      <title>RANSAC</title>
      <link>https://nuhuo08.github.io/ransac/</link>
      <pubDate>Tue, 10 Mar 2020 22:37:33 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/ransac/</guid>
      <description>在MSCKF的前端跟踪中，会使用RANSAC方法估计最优的平移量，可参考 MSCKF前端跟踪。
算法基本思想和流程 RANSAC是通过反复选择数据集去估计出模型，一直迭代到估计出认为比较好的模型。
具体的实现步骤可以分为以下几步：
 选择出可以估计出模型的最小数据集；(对于直线拟合来说就是两个点，对于计算Homography矩阵就是4个点) 使用这个数据集来计算出数据模型； 将所有数据带入这个模型，计算出“内点”的数目；(累加在一定误差范围内的适合当前迭代推出模型的数据) 比较当前模型和之前推出的最好的模型的“内点“的数量，记录最大“内点”数的模型参数和“内点”数； 重复1-4步，直到迭代结束或者当前模型已经足够好了(“内点数目大于一定数量”)。  算法输入  判断样本是否满足模型的误差容忍度t。t可以看作为对内点噪声均方差的假设，对于不同的输入数据需采用人工干预的方式预设合适的门限，且该参数对RANSAC性能有很大的影响； 随机抽取样本集S的次数。该参数直接影响余集SC中样本参与模型参数的检验次数，从而影响算法的效率，因为大部分随机抽样都受到外点的影响； 表征得到正确模型时，一致集S*的大小N。为了确保得到表征数据集P的正确模型，一般要求一致集足够大；另外，足够多的一致样本使得重新估计的模型参数更精确。 算法的迭代次数k。 适应于数据的模型model。 随机在样本抽样的数目n。  迭代次数推导    例子    </description>
    </item>
    
    <item>
      <title>大比例尺地形图测绘</title>
      <link>https://nuhuo08.github.io/large_scale_mapping/</link>
      <pubDate>Sat, 07 Mar 2020 10:36:27 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/large_scale_mapping/</guid>
      <description>平面控制测量 首级平面控制（静态）： 采用GPS静态测量技术，通过联测武汉IGS站，并已知武汉站的CGCS2000的空间三维坐标，就可以得到5个框架点在CGCS2000椭球下的三维坐标。 之所以一个已知点就可以完成转换，是因为CGCS2000和WGS-84椭球差异很小，可以认为只有一个微小量的平移。
将框架网和全面网联合平差，将上一步得到的5个框架网坐标作为已知点，平差便可以得到15个全面网点在CGCS2000椭球下的三维坐标。 当然，三维坐标通过高斯投影，很方便的就得到了所有点的CGCS2000系统下的平面坐标。
图根平面控制（GPS RTK）： 采用GPS RTK测量技术，基准站架好了以后，首先要进行点校正。 在三个已知上进行约一分钟的观测，就可以通过相对定位得到3个已知点的WGS-84坐标。 而3个已知点在CGCS2000系统下的平面坐标和大地高已知，于是通过点校正就可以将坐标系统转换到CGCS2000系统下。 这样，接下来进行的图根点坐标便是CGCS2000坐标系统下的了。
需要注意的事项和遇到的问题：
 选控制点。点位的选择要能够均匀的分布于整个测区，略有偏重的在自己测区中稍微多布设些控制点，并且需要便于调度方案的设计。 选点的时候，应该分成5个小组，并且人员相互混合后去选点。这样又能够提高效率，又能够保证每个组都有成员知道控制点在哪个地方。
 网形的设计。GPS网形设计中，最重要的便是“短边必测”。 设计不当，导致网的强度不够好，就可能导致最终的数据处理难以进行，容易超限。 并且可能需要进行跟多的时段观测，浪费人力物力。采用“翻滚式”调度方案，比较适合本队的点位分布，也能够保证网形的强度。
 各组间的约定。如果某一控制点第一次被观测，可以根据实际情况选择更好的点位。 若更换了控制点点位，一定要在新的点位边进行注明。而其它组找点的时候，若该点不是第一次观测，一定要找到有其它组进行标注过的点位。 否则一旦点位错位，就需要重新进行观测。
 配置集的设定。由于错误的将配置集设置为了“最大精度”，导致最终的数据无法用TGO导出来。 结果只好采用TEQC对数据进行提取，再通过LGO对数据文件进行分割。花费了大量的人力物力，不过好在成功的解决了问题。这也是这次实习过程中的一大收获吧。
 GPS控制网的平差。主要包括基线处理、网平差、与武汉IGS站联合平差。 这些过程在以前实习中都有接触，但是武汉IGS站的文件的预处理是一个新的知识点。 并且在这次实习中，遇到了TGO无法使用的情况，所以只好使用南方的GPS网平差软件进行结算。不过南方软件可更改的参数并不多，使用起来比较简单。
 点校正。通过GPS网平差，可以得到GPS网点的CGCS2000下的平面坐标。 通过重新对其中任意三个点进行观测，得到其WGS-84下的坐标，就可以通过点校正，建立图根点的WGS-84坐标和CGCS2000坐标之间的转换关系， 由此可以方便的进行图根点测量，得到的图根点坐标为CGCS2000下的坐标。
 做事要有始有终，谨慎再谨慎。在点校正完成以后，需要在一个一直点上进行检核，在测量完成之后，一定要进行复查。
 选图根点。图根点的选择以保证能够完成测区数字测图任务为前提进行。 图根点可适量多选，因为GPS测量图根点十分方便，一个点只需要几分钟。 倘若到真正测量数字地形图时，发现图根点不够，需要进行支导线时，就会麻烦很多。
  高程控制测量 首级高程控制（二等水准测量）： 水准测量的两个重要指标——测段往返较差、环闭合差不能超限。水准点至少要选择6个与GPS控制点重合。 进行精密水准的目的，就是测量出GPS平面控制点的正常高。
图根高程控制： 平面控制点的大地高已知后，通过高程拟合（一般为多项式拟合）便可以得到整片区域的高程异常。 这样就可以得到所有图根点的正常高。为数字地形测量提供了稳固的基础。
需要注意的事项和遇到的问题：
 i角检验。根据实习任务数要求，每个组员都要进行一次i角检验。 如果只是每天进行一次，就没法满足这个要求。所以做事不单要有始有终，还要细心仔细，看清要求。 I角检验由于形势固定不变，为了提高效率，可以在地面上做好记号，以后的每一次检验都可以不用重新拉线。
 水准点的选择。水准点至少要选择6个与GPS控制点重合。这样才能够比较好的进行高程拟合，求得图根点的正常高。为数字地形图测绘做准备。
 过渡点的选择。过渡点的是必须要有的，否则一旦出错，就要重新测量整个闭合环。 但是过渡点也不是越多越好，因为需要偶数站上过渡点，多了以后需要刻意的调节测站长度，丧失了灵活性。 一般在地面状况较好时，可以少用过渡点，而有较大高差或者地面状况较差时，则应增加过渡点。这样出错以后，返测可以减少工作量。
 过渡点的输入。第一次进行精密水准测量，总是忘记在过渡点上先“在过渡点结束”观测，然后重新进行测量。 所以在最后的数据处理时候，一旦出错，就需要通过复杂的查找，才能够确定过渡点所在的地方，才能够找到错误出现的测段。
 水准测量中的技巧。往测时需要记录手簿。只要保证记录数据时进行了回报确认以后，仪器不提示超限，那么就不需要一直等记录人员计算结束，这样可以提高效率。 并且，由于往测返测需要在同一路线上进行。所以往测时可以用粉笔或者砖头等在地面上做记号，避免返测时重新拉尺，减轻工作量。
 水准数据的编辑。由于大多数组都忘记在过渡点上停止观测，导致需要人工进行数据的编辑。 通过阅读COSALEVEL的水准文件格式说明，就可以按照“起点、终点、距离、高差、测段数”这个格式对文件进行人工提取、编辑。</description>
    </item>
    
    <item>
      <title>Control</title>
      <link>https://nuhuo08.github.io/control/</link>
      <pubDate>Wed, 12 Feb 2020 20:11:58 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/control/</guid>
      <description>PID PID原理 P Controller：将控制参数设置成误差的比例，快速接近目标，但是会造成震荡。
steering = -tau * crosstrack_error PD Controller：将误差的变化率也考虑进来。当误差变小的同时，误差的变化率也在不断变小。 两者之和将会更小，从而使控制器做出更微小的调节，防止出现控制过头，引发震荡。
steering = -tau_p * CTE - tau_d * diff_CTE where: differential crosstrack error (diff_CTE) is given by CTE(t) - CTE(t-1) PID Controller：当存在系统误差时，可以通过误差积分可以反映出来。
steering = -tau_p * CTE - tau_d * diff_CTE - tau_i * int_CTE where: the integrated crosstrack error (int_CTE) is the sum of all the previous crosstrack errors. This term works to cancel out steering drift. Twiddle Algorithm Twiddle算法提供了一套非常好的参数估计方法。当代价函数与待估参数之间没有严格的数学关系，通过twiddle算法可以高校估算出结果。</description>
    </item>
    
    <item>
      <title>Rotation</title>
      <link>https://nuhuo08.github.io/rotation/</link>
      <pubDate>Tue, 11 Feb 2020 20:28:42 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/rotation/</guid>
      <description>旋转有很多种表达形式，Active/Passive，坐标/坐标系等等。 不同的表达形式得到的矩阵表达形式有较大差异，为了避免混淆，最重要的是，给自己构建一套统一的旋转表示系统。
简单旋转 假设有一世界坐标系\(w\)，将\(w\)坐标系逆时针旋转45°，得到一个局部坐标系\(b\)。那么，在\(w\)坐标系下，坐标为\(\begin{pmatrix}1 \\ 0\end{pmatrix}\)的点，在\(b\)坐标系下的坐标是多少呢？
采用如下公式求得：
\[ r_b = R_{bw}r_w \]
其中，\(r_w\)表示点在\(w\)坐标系下的坐标，即\(\begin{pmatrix}1 \\ 0\end{pmatrix}\)。
而\(R_{bw}\)表示\(w\)相对于\(b\)的旋转。由于\(b\)是将\(w\)逆时针旋转45°得到的，也就是说，从\(b\)出发，转到\(w\)的角度为-45°，从而得到：
\[ R_{bw}=\begin{pmatrix}\cos\theta &amp; -\sin\theta \\ \sin\theta &amp; \cos\theta\end{pmatrix} =\begin{pmatrix}\cos(-45\degree) &amp; -\sin(-45\degree) \\ \sin(-45\degree) &amp; \cos(-45\degree)\end{pmatrix} =\begin{pmatrix}\frac{\sqrt{2}}{2} &amp; \frac{\sqrt{2}}{2} \\ -\frac{\sqrt{2}}{2} &amp; \frac{\sqrt{2}}{2}\end{pmatrix} \]
由此可知：
\[ r_b = R_{bw}r_w=\begin{pmatrix}\frac{\sqrt{2}}{2} \\ -\frac{\sqrt{2}}{2}\end{pmatrix} \]
这正是我们所期待的结果。
三维旋转 旋转都是按照roll，pitch，yaw的顺序进行的。这里假设分别对应的是X，Y，Z坐标轴。 若从\(w\)坐标系出发，通过旋转roll，pitch，yaw的角度后，得到\(b\)坐标系，则\(b\)坐标系下的点\(P_b\)，在\(w\)坐标系下的坐标为：
\[ \begin{aligned} P_w &amp;= R_{wb} * P_b \\[2mm] &amp;= R_z(yaw) * R_y(pitch) * R_x(roll) * P_b \\[2mm] &amp;= \begin{pmatrix} \cos &amp;-\sin &amp;0 \\ \sin &amp;\cos &amp;0 \\ 0 &amp;0 &amp;1 \end{pmatrix} \begin{pmatrix} \cos &amp;0 &amp;\sin \\ 0 &amp;1 &amp;0 \\ -\sin &amp;0 &amp;\cos \end{pmatrix} \begin{pmatrix} 1 &amp;0 &amp;0 \\ 0 &amp;\cos &amp;-\sin \\ 0 &amp;\sin &amp;\cos \end{pmatrix} * P_b \end{aligned} \]</description>
    </item>
    
    <item>
      <title>Bayesian Filter</title>
      <link>https://nuhuo08.github.io/bayesian-filter/</link>
      <pubDate>Mon, 10 Feb 2020 09:31:36 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/bayesian-filter/</guid>
      <description>Kalman Filter Imagine you are in a car equipped with sensors on the outside. The car sensors can detect objects moving around: for example, the sensors might detect a pedestrian, as described in the video, or even a bicycle. For variety, let&#39;s step through the Kalman Filter algorithm using the bicycle example.
The Kalman Filter algorithm will go through the following steps:
 first measurement - the filter will receive initial measurements of the bicycle&#39;s position relative to the car.</description>
    </item>
    
    <item>
      <title>Path Planning</title>
      <link>https://nuhuo08.github.io/path-planning/</link>
      <pubDate>Sun, 09 Feb 2020 18:22:30 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/path-planning/</guid>
      <description>search algorithms used in discrete path planning prediction which is where we use the data from sensor fusion to generate predictions about what all the other objects around us are likely to do. behavior planning: what the car shall do in the next 10 seconds or so. trajectory generation, which is where we create smooth, drivable, and collision-free trajectories.  Search    A star with heuristic function:</description>
    </item>
    
    <item>
      <title>Vim</title>
      <link>https://nuhuo08.github.io/vim/</link>
      <pubDate>Sat, 08 Feb 2020 18:10:46 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/vim/</guid>
      <description>安装 cd ~ git clone git@github.com:nuhuo08/MyVimrc.git mv MyVimrc .vim_mengqi ln -s .vim_mengqi/.vimrc .vimrc ln -s .vim_mengqi/.ackrc .ackrc # ln -s .vim_mengqi/.bash_aliases .bash_aliases cd .vim_mengqi mkdir -p cache plugged temp_dirs/undodir vi :PlugInstall #NOTE: You may need to run the command below for several times. Since downloading submodules may fail. cd ~/.vim_mengqi/plugged/YouCompleteMe git submodule update --init --recursive python3 install.py --clang-completer 常用快捷命令 ,w 保存 ,nn 打开文件浏览树 ,nf 将文件浏览树定位到当前文件 ,tb 打开函数列表 ,f 查找工程文件 ,j 最近编辑文件列表 ,g 开始查找某字符串 ,r 替换visual选中的字符串 gv 查找visual选中模式下的字符串 gcc 注释 ga*| 以|符号对选中的多行进行对齐 ctrl+n 开始多光标模式 ctrl+x 多光标模式，跳过当前词 ctrl+p 多光标模式，回到上一次选中词 ,q 打开quickfix窗口 ,n 下一个quickfix记录 ,p 上一个quickfix记录 alt+p 粘贴上一个剪切板内容 alt+m 粘贴下一个剪切板内容 g] 跳转到tag ,,w 高级的移动模式 ctrl+d 窗口翻页 ctrl+u ctrl+f ctrl+b zt 当前行在窗口的位置 zz zb * 查找并高亮字符串 # ,m 删除^M符号 gt 下一个tab gT 上一个tab 2gt 第二个tab ]c 跳到下一处Git修改处 [c ,hs git stash ,hu git undo ,hp git preview ,d	toggle gitgutter ma 设置书签a `a &amp;#39;a Vim的配置 vim有强大的可扩展性，请参考Learn Vimscript the Hard Way。</description>
    </item>
    
    <item>
      <title>Git</title>
      <link>https://nuhuo08.github.io/git/</link>
      <pubDate>Fri, 17 Jan 2020 08:00:00 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/git/</guid>
      <description>配置 SSH Key ssh-keygen -t rsa 这一步是生成了ssh的秘钥，可以建立本机与代码仓库之间的ssh链接来下载代码。
然后将~/.ssh文件夹下的id_rsa.pub文件里的文本内容，粘贴至代码服务器里面Settings --&amp;gt; SSH keys --&amp;gt; Add。
其他配置 git config命令实际上就是在修改仓库根目录下的.git/config文件。
配置git提交记录里的用户名和邮箱：
git config user.name &amp;#34;UserName&amp;#34; git config user.email &amp;#34;Example@email.com&amp;#34; Windows盘上的文件在Ubuntu下的文件模式发生了变化，导致git status时显示所有文件都有更改。 若要忽略文件模式的变化：
git config core.filemode false 当加上--global命令是，修改的是全局git配置，即~/.gitconfig
git config --global user.name &amp;#34;UserName&amp;#34; 重要命令 Branch git checkout -b develop git branch -d develop tag git tag git tag v1.4-lw git push origin v1.4-lw git push origin --tags git tag -d v1.4-lw git push origin --delete &amp;lt;tagname&amp;gt; git checkout v1.</description>
    </item>
    
    <item>
      <title>GPS/INS组合导航</title>
      <link>https://nuhuo08.github.io/gps-ins/</link>
      <pubDate>Thu, 16 Jan 2020 08:00:00 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/gps-ins/</guid>
      <description>涉及到卡尔曼滤波，最重要的是想清楚待估计的状态量，并列出动态方程、观测方程。
关于KF与Error-State KF，请参考Bayesian Filter。
常用符号 待估参数：
姿态角(roll, pitch, yaw)：
\[ (roll, pitch, yaw) \]
地理位置(latitude, longitude, height)：
\[ ( B , L , h) \]
NED系速度：
\[ (v_N, v_E, v_D) \]
子午圈、卯酉圈曲率半径：
\[ M=\frac{a(1-e^2)}{(1-e^2\sin^2 B )^{3/2}} \\[2mm] N=\frac{a}{(1-e^2\sin^2 B )^{1/2}} \]
角速度\(\omega_e=15.04107deg/h\)：
\[ \begin{aligned} \omega_{ie}^n &amp;= \begin{pmatrix} \omega_e\cos B &amp;0 &amp;-\omega_e\sin B \end{pmatrix}^T \\[2mm] \omega_{en}^n &amp;= \begin{pmatrix} \dot{ L }\cos B \\ -\dot{ B } \\ -\dot{ L }\sin B \end{pmatrix} =\begin{pmatrix} v_e/(N+h) \\ -v_N/(M+h) \\ -v_E\tan B /(N+h) \end{pmatrix} \end{aligned} \]</description>
    </item>
    
    <item>
      <title>ROS Integration</title>
      <link>https://nuhuo08.github.io/ros-integration/</link>
      <pubDate>Wed, 15 Jan 2020 08:00:00 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/ros-integration/</guid>
      <description>自动驾驶系统结构    在繁忙的工作之余，学习完这门课 Udacity - Self-Driving Car Engineer， 虽然辛苦，但是收货很多。 对无人车上配置的传感器、涉及到的功能模块、各模块之间的交互都有了大致的了解。 更有幸的是参与了自动泊车系统的研发、重构、优化等一个几乎完整的工程项目开发周期。
毕业课程项目    Nanodegree毕业课程设计，该图包含了项目涉及到的几个ROS Node，以及系统中流动的ROS Message。
tl_detector    根据图像信息：
 检测是否存在红绿灯标牌 分类是红灯还是绿灯  若检测到红灯，则将最靠近停止线的waypoint的序号发送出去。
TODO: 增加OpenCV Image Processing &amp;amp; Deep Learning跳转链接
waypoint_updater    生成前面一段需要跟踪的路径点，且增加了速度属性。当前方存在红灯时，会设置waypoints的速度慢慢减少到0停止。
waypoint_follower 采用pure pursuit算法，计算出车辆需要输出的线速度和角速度，以geometry_msgs::TwistStamped消息发送出去。
twist_controller    使用PID控制器，通过brake/throttle控制车辆的加减速度，使之达到期望的线速度。
使用YawController控制器，计算打方向盘的角度。
TODO: 增加Control跳转链接
其他 该项目没有涉及路径规划、位置确定、障碍物跟踪模块。
Planning 实际自动驾驶中，汽车跟踪的轨迹预先是不知道的，所以不会有Waypoint Loader模块。 需要根据用户的需求，做出正确的路径规划。
 类似于导航软件，根据用户指定的目的地，输出一条全局路径规划。 在跟踪全局路径时，需要有局部路径规划，控制车辆轨迹的平滑稳定。  TODO: 增加Path Planning跳转链接
Positioning 实际车辆在运行过程中，不会精确知道自己的位姿。定位所涉及的方法有：
 GPS/INS Odometry Visual/Lidar SLAM HD Map Matching  障碍物跟踪 融合多传感器的感知结果，预测与追踪障碍物的轨迹。</description>
    </item>
    
    <item>
      <title>LOAM</title>
      <link>https://nuhuo08.github.io/loam/</link>
      <pubDate>Tue, 14 Jan 2020 08:00:00 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/loam/</guid>
      <description>点云注册 坐标系统 IMU与Lidar的坐标系：x轴向前，y轴向左，z轴向上，形成右手坐标系；
LOAM内部坐标系：z轴向前，x轴向左，y轴向上，形成右手坐标系。
关于坐标系统与旋转，请参考Rotation。
重力的处理 imuHandler 需要减去重力在IMU坐标系下的分量，并将坐标系统转换成LOAM内部坐标系。
\[ \begin{aligned} \begin{pmatrix} a_x \\ a_y \\ a_z \end{pmatrix} &amp;=R_{bw} *\begin{pmatrix} 0 \\ 0 \\ g \\ \end{pmatrix} \\[2mm] &amp;=R_x(-roll)*R_y(-pitch)*R_z(-yaw) *\begin{pmatrix} 0 \\ 0 \\ g \\ \end{pmatrix} \\[2mm] &amp;=\begin{pmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; cos(roll) &amp; sin(roll) \\ 0 &amp; -sin(roll) &amp; cos(roll) \end{pmatrix} *\begin{pmatrix} cos(pitch) &amp; 0 &amp; -sin(pitch) \\ 0 &amp; 1 &amp; 0 \\ sin(pitch) &amp; 0 &amp; cos(pitch) \end{pmatrix} *\begin{pmatrix} cos(yaw) &amp; sin(yaw) &amp; 0 \\ -sin(yaw) &amp; cos(yaw) &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{pmatrix} *\begin{pmatrix} 0 \\ 0 \\ g \\ \end{pmatrix} \\[2mm] &amp;=\begin{pmatrix} -g\cdot sin(pitch) \\ g\cdot cos(pitch)sin(roll) \\ g\cdot cos(pitch)cos(roll) \end{pmatrix} \end{aligned} \]</description>
    </item>
    
    <item>
      <title>GNSS定位原理</title>
      <link>https://nuhuo08.github.io/rtk/</link>
      <pubDate>Mon, 13 Jan 2020 08:00:00 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/rtk/</guid>
      <description>数据文件介绍 观测文件 观测文件记录了该观测站能够观测到的卫星及其对应的伪距、载波观测值。
 01 9 4 9 40 0.0000000 0 7G 1G 4G 7G13G20G24G25 20532012.14648 20532011.55846 20532016.22546 107896448.4014 84075170.1284 -702.033 -547.047 21255524.69947 21255524.94445 21255529.02045 111698540.8774 87037834.1244 799.589 623.056 24648794.02245 24648792.88941 24648801.63741 129530300.6484 100932694.9344 -3425.352 -2669.144 21267718.45748 21267718.52445 21267722.00945 111762613.2534 87087766.9504 1911.882 1489.773 21900010.88847 21900009.74444 21900015.95344 115085325.1934 89676892.5064 -3011.439 -2346.579 23828505.41246 23828504.07842 23828511.81542 125219643.5474 97573763.5014 2743.177 2137.544 24104647.59546 24104646.97742 24104654.81342 126670763.8784 98704504.1444 -2800.638 -2182.275  导航文件 导航文件用来计算卫星在某一时刻的位置。
 7 01 9 4 9 59 44.</description>
    </item>
    
    <item>
      <title>Software Defined Receiver</title>
      <link>https://nuhuo08.github.io/sdr/</link>
      <pubDate>Sun, 12 Jan 2020 08:00:00 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/sdr/</guid>
      <description>GPS信号组成 载波 载波即为一个个正弦波，没有任何标记，作为信号的载体发射出去。
   信号 特点     \(L_1\) \(f_1=1575.42MHz=154f_0\)，\(\lambda_1 \approx 19.0cm\)   \(L_2\) \(f_1=1227.60MHz=120f_0\)，\(\lambda_2 \approx 24.4cm\)    其中，\(f_0=10.23MHz\)为原子钟所提供的基准频率。
伪码 伪码：伪随机噪声码。对于某一颗卫星的伪码，与其他卫星的伪码互相关值为0；与自身伪码相位完全对齐时相关值为1，相位不对齐时为0。 与随机噪声的特点相似，故称为伪码。
   信号 特点     \(C/A\)码 仅调制在\(L_1\)上，长度为1023个码片，每毫秒重复一周，码宽约293m，一个码片的时间内载波\(L_1\)重复1540周   \(P码\) 同时调制在\(L_1\)和\(L_2\)上，每7天重复一周，码宽约30m    数据码  载波L1、C/A码、数据码三者之间的长度关系
  数据码解译出来，即为导航星历，用于计算某一时刻卫星的位置。
   信号 特点     1帧 1500比特组成，每帧30s，分成5子帧   1子帧 300比特组成，每子帧6s，分成10字   1字 30比特组成，每字0.</description>
    </item>
    
    <item>
      <title>Factor Graph</title>
      <link>https://nuhuo08.github.io/factor-graph/</link>
      <pubDate>Sat, 11 Jan 2020 08:00:00 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/factor-graph/</guid>
      <description>为什么使用因子图 通常我们并不关心观测量，只有在状态确定的情况下，讨论观测量才有意义。因此用因子图表达更突出重点，即状态变量。
与传统优化算法的关系 通常，传统算法作用在信息矩阵上。信息矩阵对应于一个无向马尔科夫图，通过Cholesky分解LU后，可以求解变量。
因子图直接作用在雅克比矩阵上。通过QR分解逐步消元，得到的R矩阵与上面的LU矩阵存在关系（相同？）。
优势  可以迭代递推，不需要重新对整个雅克比矩阵QR分解 通过贝叶斯树，可以非常清晰的看到，当新的观测量出现时，哪部分矩阵会受到影响，需要重新计算。避免其他大量不受影响状态的重复计算  </description>
    </item>
    
    <item>
      <title>Matrix Decomposition</title>
      <link>https://nuhuo08.github.io/matrix/</link>
      <pubDate>Fri, 10 Jan 2020 08:00:00 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/matrix/</guid>
      <description>LU &amp;amp; LDU    LDL &amp;amp; LL 只适用于对称矩阵       QR分解    Householder Method 镜像变换，For each i-th column of A, “zero out” rows i+1 and lower
   Givens Don’t reflect; rotate instead, Introduces zeroes into A one at a time
   Gram-Schmidt Iteratively express each new column vector as a linear combination of previous columns, plus some (normalized) orthogonal component</description>
    </item>
    
    <item>
      <title>ROS Navigation Stack</title>
      <link>https://nuhuo08.github.io/navigation-stack/</link>
      <pubDate>Thu, 09 Jan 2020 08:00:00 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/navigation-stack/</guid>
      <description>ROS系统结构 ROS Node ROS Node: 功能模块以Node的形式，处理某一特定的任务。    ROS Master: 记录所有现存的node，保证node之间的信息交流。parameter server运行在其中，实现参数与配置信息的共享。    ROS信息交互 单向通信：一个node发布topic，一个node订阅该topic    双向通信：一个node向另一个node发送信息并请求回复，使用service    查看ROS信息 rosnode list rostopic list rosservice list rostopic info /turtle1/cmd_vel rosmsg info geometry_msgs/Twist rqt_graph    ROS安装 ROS官网教程：ROS Tutorials
安装ROS基本功能包 由于Ubuntu默认软件源在国内访问速度较慢，建议切换到阿里云。
安装ROS：
sudo sh -c &amp;#39;. /etc/lsb-release &amp;amp;&amp;amp; echo &amp;#34;deb http://mirrors.ustc.edu.cn/ros/ubuntu/ `lsb_release -cs` main&amp;#34; &amp;gt; /etc/apt/sources.list.d/ros-latest.list&amp;#39; sudo apt-key adv --keyserver &amp;#39;hkp://keyserver.ubuntu.com:80&amp;#39; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 sudo apt-get update sudo apt-get install ros-kinetic-desktop-full sudo rosdep init rosdep update echo &amp;#34;source /opt/ros/kinetic/setup.</description>
    </item>
    
    <item>
      <title>GMapping</title>
      <link>https://nuhuo08.github.io/gmapping/</link>
      <pubDate>Wed, 08 Jan 2020 08:00:00 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/gmapping/</guid>
      <description>基本理论 粒子滤波基本原理请参考 Particle Filter
SLAM问题的分解 \[ \begin{aligned} p(x_{1:t},m|u_{1:t},z_{1:t}) &amp;= p(x_{1:t}|u_{1:t},z_{1:t}) p(m|u_{1:t},z_{1:t})\\ &amp;= p(x_{1:t}|u_{1:t},z_{1:t}) p(m|z_{1:t}) \end{aligned} \]
将SLAM问题分解为：机器人的定位；基于已知机器人位姿的构图。
Fast-SLAM 根据贝叶斯公式，可以将机器人位姿的估计，转换成一个增量估计问题。
\[ \begin{aligned} p(x_{1:t}|u_{1:t},z_{1:t}) &amp;= \eta p(z_t|x_{1:t},u_{1:t},z_{1:t-1}) p(x_{1:t}|z_{1:t-1},u_{1,t})\\ &amp;= \eta p(z_t|x_t) p(x_{1:t}|z_{1:t-1},u_{1:t})\\ &amp;= \eta p(z_t|x_t) p(x_t|x_{1:t-1},z_{1:t-1},u_{1:t}) p(x_{1:t-1}|z_{1:t-1},u_{1:t})\\ &amp;= \eta p(z_t|x_t) p(x_t|x_{t-1},u_{1:t}) p(x_{1:t-1}|z_{1:t-1},u_{1:t-1}) \end{aligned} \]
其中，\(p(x_{1:t-1}|z_{1:t-1},u_{1:t-1})\)通过粒子群来表示； \(p(x_t|x_{t-1},u_{1:t})\)对每个粒子进行运动学模型的传播； \(p(z_t|x_t)\)根据观测模型计算权重。
数据结构相关 Map template &amp;lt;class Cell, const bool debug=false&amp;gt; class Array2D{}; template &amp;lt;class Cell&amp;gt; class HierarchicalArray2D: public Array2D&amp;lt;autoptr&amp;lt; Array2D&amp;lt;Cell&amp;gt; &amp;gt; &amp;gt;{}; template &amp;lt;class Cell, class Storage, const bool isClass=true&amp;gt; class Map{}; typedef Map&amp;lt;PointAccumulator,HierarchicalArray2D&amp;lt;PointAccumulator&amp;gt; &amp;gt; ScanMatcherMap;  Array2D是一个二维数组，HierarchicalArray2D是一个Array2D的二维数组。 相当于将地图先分割成分辨率比较低的网格，只有当粒子运动到该网格时，才真正分配这个网格的内存。 网格的内存对应着分辨率高的真实的地图，用PointAccumulator来进行计数，记录激光是否通过该点，从而判断改点的状态：占据、空闲、未知。</description>
    </item>
    
    <item>
      <title>SLAM for Dummies</title>
      <link>https://nuhuo08.github.io/slam-for-dummies/</link>
      <pubDate>Tue, 07 Jan 2020 08:00:00 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/slam-for-dummies/</guid>
      <description>TO BE CONTINUED
https://zhuanlan.zhihu.com/p/32937247
观测方程 \[ \underbrace{\begin{pmatrix} r_1 \\ \theta_1 \\ r_2 \\ \theta_2 \\ \vdots \\ r_n \\ \theta_n \end{pmatrix}}_Z = \underbrace{\begin{bmatrix} A_1 &amp;B_1 &amp;C_1 &amp;-A_1 &amp;-B_1 \\ D_1 &amp;E_1 &amp;F_1 &amp;-D_1 &amp;-E_1 \\ A_2 &amp;B_2 &amp;C_2 &amp; &amp; &amp;-A_2 &amp;-B_2 \\ D_2 &amp;E_2 &amp;F_2 &amp; &amp; &amp;-D_2 &amp;-E_2 \\ &amp;\vdots &amp; &amp; &amp; &amp; &amp; &amp; \ddots \\ A_n &amp;B_n &amp;C_n &amp; &amp; &amp; &amp; &amp; &amp;-A_n &amp;-B_n \\ D_n &amp;E_n &amp;F_n &amp; &amp; &amp; &amp; &amp; &amp;-D_n &amp;-E_n \\ \end{bmatrix}}_H \underbrace{\begin{pmatrix} x_r \\ y_r \\ \theta_r \\ x_1 \\ y_1 \\ x_2 \\ y_2 \\ \vdots \\ x_n \\ y_n \end{pmatrix}}_X \\[2mm] R = \begin{pmatrix} r_c &amp; \\ &amp;r_d \end{pmatrix} \]</description>
    </item>
    
    <item>
      <title>非线性优化</title>
      <link>https://nuhuo08.github.io/non-linear/</link>
      <pubDate>Mon, 06 Jan 2020 08:00:00 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/non-linear/</guid>
      <description>优化方法比较    方法 特点     梯度下降法 \(x_{i+1}=x_i-\eta \frac{\partial f}{\partial x}\)，效率高，但可能收敛慢   牛顿法 二阶泰勒展开，计算Hessian矩阵耗时，离初值远不收敛，极小值处接近二次函数   高斯-牛顿法 仅适用于最小二乘问题，以Jacobian矩阵\(J^TJ\)代替\(H\)，离初值远不收敛，\(J^TJ\)近奇异不收敛   L-M法 \(\left(H+\lambda I\right)\Sigma=-J^Tr\)，残差增大时，放大\(\lambda\)，成为梯度下降；残差减小时，减小\(\lambda\)，成为高斯-牛顿    g2o g2o在ORB-SLAM2中的用法 Ceres http://ceres-solver.org/nnls_modeling.html
对于以下代价函数：
\[ \frac{1}{2} \sum_i \rho_i(\parallel f_i(x_{i1}, x_{i2}, \cdots, x_{ik}) \parallel ^2) \]
在Ceres中，\(\rho\)为loss function，用于减弱外点的影响；\(f\)为cost function，定义了残差的计算方式；\((x_{i1}, x_{i2}, \cdots, x_{ik})\)为parameter block，定义了需要估计的变量；\(\rho_i(\parallel f_i(x_{i1}, x_{i2}, \cdots, x_{ik}) \parallel ^2)\)为residual block，定义了一个残差块。
AddResidualBlock problem.AddResidualBlock(costfunction, lossfunction, x1, x2 ... xn)
其中，\(x_1, x_2, \cdots x_n\)要与costfunction中的变量维数要对应起来。</description>
    </item>
    
    <item>
      <title>VINS-MONO</title>
      <link>https://nuhuo08.github.io/vins-mono/</link>
      <pubDate>Sun, 05 Jan 2020 08:00:00 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/vins-mono/</guid>
      <description>代码流程图    预积分的协方差 预积分值可以作为一种观测量，约束两个时刻状态间的关系。为了确定预积分值的精度（协方差），需要求解出其递推关系。
预积分公式推导 \(b_k^a\)和\(b_k^g\)作为随机游走噪声，在推导\(k \sim k+1\)时认为是常数！不像\(w\)和\(a\)，要添加\(n_k^g\)和\(n_k^a\)噪声进去
\[ \begin{aligned} \omega&amp;=\frac{1}{2}( (\omega^{b_k}+n_k^g-b_k^g) + (\omega^{b_{k+1}}+n_{k+1}^g-b_k^g) ) \\[2mm] q_{b_ib_{k+1}}&amp;=q_{b_ib_k}\otimes\begin{bmatrix}1 \\ \frac{1}{2}\omega\delta{t}\end{bmatrix} \\[2mm] a&amp;=\frac{1}{2}( q_{b_ib_k}(a^{b_k}+n_k^a-b_k^a) + q_{b_ib_{k+1}}(a^{b_{k+1}}+n_{k+1}^a-b_k^a) ) \\[2mm] \beta_{b_ib_{k+1}}&amp;=\beta_{b_ib_k}+a\delta{t} \\[2mm] \alpha_{b_ib_{k+1}}&amp;=\alpha_{b_ib_k}+\beta_{b_ib_k}\delta{t}+\frac{1}{2}a\delta{t}^2 \\[2mm] b_{k+1}^a&amp;=b_k^a+n_{b_k^a}\delta{t} \\[2mm] b_{k+1}^g&amp;=b_k^g+n_{b_k^g}\delta{t} \\[2mm] \end{aligned} \]
写成矩阵形式：
\[ \begin{bmatrix}\alpha_{b_ib_{k+1}} \\ \theta_{b_ib_{k+1}} \\ \beta_{b_ib_{k+1}} \\ b_{k+1}^a \\ b_{k+1}^g\end{bmatrix} =F*\begin{bmatrix}\alpha_{b_ib_{k}} \\ \theta_{b_ib_{k}} \\ \beta_{b_ib_{k}} \\ b_{k}^a \\ b_{k}^g\end{bmatrix} +G*\begin{bmatrix}n_k^a \\ n_k^g \\ n_{k+1}^a \\ n_{k+1}^g \\ n_{k}^a \\ n_{k}^g \end{bmatrix} \]</description>
    </item>
    
    <item>
      <title>ORB-SLAM2</title>
      <link>https://nuhuo08.github.io/orb-slam2/</link>
      <pubDate>Sat, 04 Jan 2020 08:00:00 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/orb-slam2/</guid>
      <description>Tracking Initialization SearchForInitialization --&amp;gt; Initialize(RANSAC) --&amp;gt; GlobalBundleAdjustemnt --&amp;gt; ComputeSceneMedianDepth
SearchForInitialization:
GetFeaturesInArea --&amp;gt; DescriptorDistance --&amp;gt; ComputeThreeMaxima
ORB特征
Oriented FAST关键点：
 比较像素点周围圆上的像素间亮度的差异 非极大值抑制，在一定区域内仅保留响应极大值的角点，避免太集中 对角点计算Harris响应值，仅保留前N个具有最大响应值的角点 构建金字塔，在金字塔每一层检测角点。实现尺度不变 灰度质心法，连接图像块的几何中心与质心。实现旋转不变  BRIEF描述子：
 随机选点并比较灰度，组成128维的二进制数组 使用Hamming distance作为度量，即不同位数的个数  F矩阵
https://zhuanlan.zhihu.com/p/61614421
在求解F和H矩阵之前，应该首先进行特征点归一化，保证坐标均值为0，一阶绝对矩为1。(MVG P67，归一化才能消除坐标变换的影响)
设\(p1\)，\(p2\)为像素坐标，可知：
\[ p_2 = K (RP + t) \\[2mm] p_1 = KP \]
从上述\(p1\)，\(p2\)的关系式出发，导出：
\[ (K^{-1} p_2)^T t^{\wedge} K^{-1} p_2 = 0 = p_2^T K^{-T} t^{\wedge} R K^{-1} p_1 = p_2^T F p_1 \]
一对匹配的像素点可以写1个方程，考虑到尺度等价性，使用八点法即可求解\(F\)矩阵。</description>
    </item>
    
    <item>
      <title>MSCKF</title>
      <link>https://nuhuo08.github.io/msckf/</link>
      <pubDate>Fri, 03 Jan 2020 08:00:00 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/msckf/</guid>
      <description>前端跟踪  根据IMU给出的旋转量，假设相机发生了纯旋转，估算下一帧特征点的位置； 使用LK光流法，进一步优化特征点的位置； 判断是否为纯旋转。若不是纯旋转，则使用RANSAC方法，随机选2个点，估算出最优的平移量； 将图像分成网格，每个网格最多4个特征点，保证特征点均匀分布。  QR分解 \[ A_{2m \times 3} = Q_{2m \times 2m}R_{2m \times 3} = \begin{bmatrix} B_{2m \times 3} &amp;C_{2m \times (2m - 3)} \end{bmatrix} \begin{bmatrix} D_{3 \times 3} \\ 0_{(2m - 3) \times 3} \end{bmatrix} \]
其中，\(Q\) 为正交矩阵，每一列代表一个基向量，与除了自身以外的其他基向量的点积都为0。Where \(B\) and \(C\) are unitary matrices whose columns form bases for the range and nullspace of \(A\).
\[ {C^T}_{(2m-3) * 2m} A_{2m \times 3} = \begin{bmatrix} 0_{(2m-3) \times 3} &amp;I_{(2m-3) \times (2m - 3)} \end{bmatrix} \begin{bmatrix} D_{3 \times 3} \\ 0_{(2m - 3) \times 3} \end{bmatrix} = 0_{(2m-3) \times 3} \]</description>
    </item>
    
    <item>
      <title>AMCL</title>
      <link>https://nuhuo08.github.io/amcl/</link>
      <pubDate>Thu, 02 Jan 2020 08:00:00 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/amcl/</guid>
      <description>ROS-AMCL    粒子滤波基本原理请参考 Particle Filter
粒子聚类 对外输出的机器人状态不应该是某一个最好的粒子，因为很有可能某些粒子的值都非常接近，可能会引起频繁的粒子切换，导致输出的结果来回跳变。
基于此考虑， 应该对相似的粒子进行聚类。将最好的那一簇粒子的统计状态作为输出的机器人状态。
KD-Tree 当涉及到距离查找时，作为算法工程师，我们应该首先想到KD-Tree。树的叶子节点是每一个粒子，而非叶子节点则保存的是该节点的分叉判断的标准，小于此分叉判断标准的在左边，大于此分叉标准的在右边。
查询的基本思路：首先通过二叉树搜索（比较待查询节点和分裂节点的分裂维的值，小于等于就进入左子树分支，等于就进入右子树分支直到叶子结点），顺着“搜索路径”很快能找到最近邻的近似点，也就是与待查询点处于同一个子空间的叶子结点；然后再回溯搜索路径，并判断搜索路径上的结点的其他子结点空间中是否可能有距离查询点更近的数据点，如果有可能，则需要跳到其他子结点空间中去搜索（将其他子结点加入到搜索路径）。重复这个过程直到搜索路径为空。
   聚类 循环遍历每一个叶子节点，在叶子节点周围的 +-1 范围内的粒子都归为一类。例如在AMCL中，每个粒子周围27个粒子若有相连的，就将它们全部连成一片，形成一簇粒子。
粒子滤波改进 为了防止机器人被绑架，出现粒子收敛于某一错误的地方，需要进行粒子滤波的改良。
粒子注入 我们来考虑如下的式子：
\[ x_1 = x + 0.1(y-x) \\[2mm] x_2 = x + 0.9(y-x) \]
对于上面两个式子，展开以后我们可以发现：\(x_1\) 主要受到 \(x\) 的影响，而 \(x_2\) 主要受到 \(y\) 的影响。若粒子收敛于正确的状态，则 \(y\) 是准确的，\(x_2\) 将会比 \(x_1\) 更大，此时不需要注入粒子。若粒子收敛于错误的地方，则 \(y\) 不准确，此时 \(x_1\) 受到 \(y\) 的影响较小，\(x_1\) 更准确，此时便需要注入粒子。
而这正是AMCL里面slow和fast参数产生的效果。
KLD自适应 KLD的计算属于数理统计的知识，可参考论文1。这里进行直观的解释。
例如，某一粒子权值很大。当我们进行100次采样，可能都采样到的是同一个粒子，此时粒子的个数始终保持为1。而KLD计算出来的需要采样的次数，是粒子个数的函数。因此，当粒子数保持为1时，KLD计算出来的次数为某一定值，而采样次数持续在增加，到某一时间点，便超过了需要的采样次数。
而当粒子权值都接近时，假设我们采样了100次，每次采样出来的粒子都不同，此时粒子的个数一直增长到100。此时的KLD也随着粒子的个数增长到一个比较大的值。采样的次数虽然持续增加，但是始终超过不了KDL计算出来的次数。此种情况下采样仍将继续。
距离计算 计算每个粒子的权重时，我们需要计算观测到的障碍物与地图中的障碍物的距离差异。差异越大，权值越小。当某次观测的障碍物全部与地图上的障碍物匹配上了，则差异为0，权值极大。因此，在地图的初始阶段，我们需要计算地图上任一点位置到最近障碍物的距离。这就是似然场模型。
直接计算 遍历每一个点，计算每一个点到每个障碍物的距离并取最小值。此方法进行了重复计算，效率较低。
高效算法 从障碍物出发，向外膨胀一个单位。当所有障碍物膨胀完以后，从膨胀出来的地方出发，继续向外膨胀一个单位。此方法没有冗余计算，且实现的代码简洁。
AMCL参数解读 min_particles / max_particles / kld_err / kld_z : 用来限制粒子数量</description>
    </item>
    
    <item>
      <title>Hugo搭建网站</title>
      <link>https://nuhuo08.github.io/hugo-website/</link>
      <pubDate>Wed, 01 Jan 2020 08:00:00 +0800</pubDate>
      
      <guid>https://nuhuo08.github.io/hugo-website/</guid>
      <description>申请Github账号 Github私人博客仓库 新建Hugo_Blogs仓库，此仓库保存个人的markdown源文件等。可设置为private仓库。
Github Pages 新建username.github.io的仓库，此仓库保存Hugo生成出来的html文件等。https://username.github.io/即为最终的个人博客地址。必须设置为public仓库。
安装Hugo Hugo Tutorial
Binary Package
新建私人博客文件夹 创建网站文件夹 新建网站文件夹，并用hugo生成基本网站文件
mkdir MyWebsite &amp;amp;&amp;amp; cd MyWebsite hugo new site . 链接Github私人博客仓库 添加git源，保存私人的markdown源文件
git init git remote add origin https://github.com/username/Hugo_Blogs.git 添加并使用新的theme git submodule add https://github.com/nuhuo08/uswds-hugo-theme.git themes/uswds-hugo-theme git submodule update --remote --merge cp themes/uswds-hugo-theme/exampleSite/config.yaml . 修改配置 设置 utterances，链接到username/username.github.io仓库，开启utterance修改Issue的权限。
在config.yaml文件中，修改params.utter.repo属性为username/username.github.io；
修改baseURL属性为https://username.github.io/
编辑网页 链接Github Pages 为了能够使用git submodule，需要先在仓库里添加点文件，之后再把它删掉。
mkdir public &amp;amp;&amp;amp; cd public &amp;amp;&amp;amp; touch abc git remote add origin https://github.com/username/username.github.io.git git add .</description>
    </item>
    
  </channel>
</rss>