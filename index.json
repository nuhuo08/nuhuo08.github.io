{"hugo":{"BuildDate":"2020-01-05T18:57:23Z","CommitHash":"83e50184","Environment":"production","Version":"0.62.2"},"pages":[{"Aliases":null,"File":{"BaseFileName":"index","ContentBaseName":"sdr","Dir":"blog/gps/sdr/","Ext":"md","Lang":"en","LogicalName":"index.md","Path":"blog/gps/sdr/index.md","TranslationBaseName":"index","UniqueID":"16b474b72bfb6fd226f35a1e635c65ce"},"FuzzyWordCount":100,"GitInfo":null,"Kind":"page","Lastmod":"2020-01-12T08:00:00+08:00","Len":8041,"Name":"Software Defined Receiver","Permalink":"https://nuhuo08.github.io/sdr/","Plain":"GPS信号组成 载波 载波即为一个个正弦波，没有任何标记，作为信号的载体发射出去。\n   信号 特点     \\(L_1\\) \\(f_1=1575.42MHz=154f_0\\)，\\(\\lambda_1 \\approx 19.0cm\\)   \\(L_2\\) \\(f_1=1227.60MHz=120f_0\\)，\\(\\lambda_2 \\approx 24.4cm\\)    其中，\\(f_0=10.23MHz\\)为原子钟所提供的基准频率。\n伪码 伪码：伪随机噪声码。对于某一颗卫星的伪码，与其他卫星的伪码互相关值为0；与自身伪码相位完全对齐时相关值为1，相位不对齐时为0。 与随机噪声的特点相似，故称为伪码。\n   信号 特点     \\(C/A\\)码 仅调制在\\(L_1\\)上，长度为1023个码片，每毫秒重复一周，码宽约293m，一个码片的时间内载波\\(L_1\\)重复1540周   \\(P码\\) 同时调制在\\(L_1\\)和\\(L_2\\)上，每7天重复一周，码宽约30m    数据码  载波L1、C/A码、数据码三者之间的长度关系\n  数据码解译出来，即为导航星历，用于计算某一时刻卫星的位置。\n   信号 特点     1帧 1500比特组成，每帧30s，分成5子帧   1子帧 300比特组成，每子帧6s，分成10字   1字 30比特组成，每字0.6s，最高位比特先被发送，6比特的奇偶校验码结束。   1比特 每比特20ms，期间\\(C/A\\)码重复20个周期     导航电文的结构\n  信号捕获 二维搜索范围包括41个搜索频带和2046个搜索码带，搜索范围太大。 通过并行频率搜索、并行码相位搜索，可以大幅度提高搜索效率。利用傅里叶变换实现并行搜索。\n并行频率搜索  并行频率搜索捕获算法流程\n  并行码相位搜索  并行码相位搜索捕获算法流程\n  两个序列\\(x(n)\\)与\\(y(n)\\)在时域内做相关运算，相当于他们的离散傅里叶变换\\(X(k)\\)与\\(Y(k)\\)的共轭\\(\\overline{Y(k)}\\)在频域内做乘积运算。 反过来，成绩\\(X(k)\\overline{Y(k)}\\)的离散傅里叶反变换正好是接收机需要进行检测的在各个码相位处的相关值\\(\\mathcal{z}(n)\\)。\n跟踪环路  一种典型的接收机跟踪环路\n  载波相位观测值  数字中频信号\\(s_{IF}(n)\\)与载波环所复制的载波混频相乘，其中\\(I\\)支路为正弦波，\\(Q\\)支路为余弦波：得到\\(i\\)和\\(q\\)； 与码环所复制的即时\\(C/A\\)码做相关运算：剥离\\(C/A\\)码信号，得到\\(i_P\\)和\\(q_P\\)； 进行相干积分：滤除高频信号，得到\\(I_P\\)和\\(Q_P\\)信号； 输入到载波环鉴别器，得到\\(\\phi_e\\)或\\(f_e\\)，用于调整载波数控振荡器； 输出观测量：多普勒频移、积分多普勒、载波相位测量值、导航电文数据比特。  码观测值  数字中频信号\\(s_{IF}(n)\\)与载波环所复制的载波混频相乘，其中\\(I\\)支路为正弦波，\\(Q\\)支路为余弦波：得到\\(i\\)和\\(q\\)； 与码环所复制的超前、滞后\\(C/A\\)码做相关运算：剥离\\(C/A\\)码信号，得到\\(i_E\\)、\\(q_E\\)、\\(i_L\\)、\\(q_L\\)； 进行相干积分：滤除高频信号，得到\\(I_E\\)、\\(Q_E\\)、\\(I_L\\)、\\(Q_L\\)信号； 输入到码环鉴别器，得到\\(IQ\\)支路的幅值\\(E\\)和\\(L\\)，并进行非相干积分，并得到\\(\\delta_cp\\)，用于调整\\(C/A\\)码数控振荡器； 输出观测量：码相位、伪距测量值。  基带数字信号处理 位同步 帧同步 奇偶校验与电文译码 测量值的生成  卫星发射信号时间的组成部分\n  \\[ t^{(s)}=TOW+(30w+b)\\times 0.020+\\left(c+\\frac{CP}{1023}\\right)\\times 0.001\\ (s) \\\\[2mm] \\rho (t)=c\\left(t_u(t)-t^{(s)}(t-\\tau)\\right) \\]\n学习资料 GPS原理与接收机设计\nA Software-Defined GPS and Galileo Receiver: A Single-Frequency Approach\nGPS全球定位接收机——原理与软件实现\n","PublishDate":"2020-01-12T08:00:00+08:00","ReadingTime":1,"RelPermalink":"/sdr/","Section":"blog","Stat":{"IsDir":false,"ModTime":"2020-01-28T21:42:26.515590428+08:00","Mode":436,"Name":"index.md","Size":5129},"Tags":null,"Title":"Software Defined Receiver","Type":"blog","Weight":0,"WordCount":87},{"Aliases":null,"File":{"BaseFileName":"index","ContentBaseName":"factor-graph","Dir":"blog/math/factor-graph/","Ext":"md","Lang":"en","LogicalName":"index.md","Path":"blog/math/factor-graph/index.md","TranslationBaseName":"index","UniqueID":"38daecff3d2f657f782298d43a87f9a7"},"FuzzyWordCount":100,"GitInfo":{"hash":"7e7a2000c988b2460dc5b2136847965e9905fdd8","abbreviatedHash":"7e7a200","subject":"1. add matrix page 2. add factor-graph page","authorName":"nuhuo08","authorEmail":"845776955@qq.com","authorDate":"2020-01-28T00:53:30+08:00","commitDate":"2020-01-28T00:53:30+08:00"},"Kind":"page","Lastmod":"2020-01-28T00:53:30+08:00","Len":933,"Name":"因子图的一些思考","Permalink":"https://nuhuo08.github.io/factor-graph/","Plain":"为什么使用因子图 通常我们并不关心观测量，只有在状态确定的情况下，讨论观测量才有意义。因此用因子图表达更突出重点，即状态变量。\n与传统优化算法的关系 通常，传统算法作用在信息矩阵上。信息矩阵对应于一个无向马尔科夫图，通过Cholesky分解LU后，可以求解变量。\n因子图直接作用在雅克比矩阵上。通过QR分解逐步消元，得到的R矩阵与上面的LU矩阵存在关系（相同？）。\n优势  可以迭代递推，不需要重新对整个雅克比矩阵QR分解 通过贝叶斯树，可以非常清晰的看到，当新的观测量出现时，哪部分矩阵会受到影响，需要重新计算。避免其他大量不受影响状态的重复计算  ","PublishDate":"2020-01-11T08:00:00+08:00","ReadingTime":1,"RelPermalink":"/factor-graph/","Section":"blog","Stat":{"IsDir":false,"ModTime":"2020-01-27T23:52:35.685721568+08:00","Mode":436,"Name":"index.md","Size":893},"Tags":null,"Title":"因子图的一些思考","Type":"blog","Weight":0,"WordCount":8},{"Aliases":null,"File":{"BaseFileName":"index","ContentBaseName":"matrix","Dir":"blog/math/matrix/","Ext":"md","Lang":"en","LogicalName":"index.md","Path":"blog/math/matrix/index.md","TranslationBaseName":"index","UniqueID":"3615206ab9f107f87e7a76bbe545d0d2"},"FuzzyWordCount":200,"GitInfo":{"hash":"7e7a2000c988b2460dc5b2136847965e9905fdd8","abbreviatedHash":"7e7a200","subject":"1. add matrix page 2. add factor-graph page","authorName":"nuhuo08","authorEmail":"845776955@qq.com","authorDate":"2020-01-28T00:53:30+08:00","commitDate":"2020-01-28T00:53:30+08:00"},"Kind":"page","Lastmod":"2020-01-28T00:53:30+08:00","Len":5588,"Name":"Matrix Decomposition","Permalink":"https://nuhuo08.github.io/matrix/","Plain":"LU \u0026amp; LDU    LDL \u0026amp; LL 只适用于对称矩阵       QR分解    Householder Method 镜像变换，For each i-th column of A, “zero out” rows i+1 and lower\n   Givens Don’t reflect; rotate instead, Introduces zeroes into A one at a time\n   Gram-Schmidt Iteratively express each new column vector as a linear combination of previous columns, plus some (normalized) orthogonal component\nSVD分解    作用 对角矩阵：对坐标轴进行缩放\n三角矩阵：切变Shear\n正交矩阵：旋转\n方程求解 LU中，LU为三角阵，递归带入求解方程\nQR中Q为正交阵，逆矩阵即转置，容易求解\nNullSpace Let A be an m-by-n matrix with rank n. QR decomposition finds orthonormal m-by-m matrix Q and upper triangular m-by-n matrix R such that A = QR. If we define Q = [Q1 Q2], where Q1 is m-by-n and Q2 is m-by-(m-n), then the columns of Q2 form the null space of A^T.\nQR decomposition is computed either by Gram-Schmidt, Givens rotations, or Householder reflections. They have different stability properties and operation counts.\n稀疏矩阵的重排序 （1）原始稀疏矩阵，进行Cholesky分解后，存在大量非零元素8.24%\n   Original Sparse Matrix Cholesky Decomposition          （2）采用Nested Dissection Permutation方法进行排序后，再进行Cholesky分解，非零元素显著减少，仅0.68%\n   Nested Dissection Cholesky Decomposition          （3）各排序方法的比较    建议  先边缘化掉地图点，因为地图点之间一般是独立的 再边缘化掉位姿。边缘化位姿时，会造成矩阵稠密 稠密矩阵解算时，可以先进行排序，再进行Cholesky分解  SVD \u0026amp; PCA SVD vs PCA\n      ","PublishDate":"2020-01-10T08:00:00+08:00","ReadingTime":1,"RelPermalink":"/matrix/","Section":"blog","Stat":{"IsDir":false,"ModTime":"2020-01-28T00:34:15.496811582+08:00","Mode":436,"Name":"index.md","Size":2975},"Tags":null,"Title":"Matrix Decomposition","Type":"blog","Weight":0,"WordCount":161},{"Aliases":null,"File":{"BaseFileName":"index","ContentBaseName":"navigation-stack","Dir":"blog/ros/navigation-stack/","Ext":"md","Lang":"en","LogicalName":"index.md","Path":"blog/ros/navigation-stack/index.md","TranslationBaseName":"index","UniqueID":"7816e9dc1695358c0f2914dd6c964abd"},"FuzzyWordCount":200,"GitInfo":{"hash":"701154c262422f11f8f133c8717c04c31e75eab1","abbreviatedHash":"701154c","subject":"add navigation-stack page","authorName":"nuhuo08","authorEmail":"845776955@qq.com","authorDate":"2020-01-27T21:52:13+08:00","commitDate":"2020-01-27T21:52:13+08:00"},"Kind":"page","Lastmod":"2020-01-27T21:52:13+08:00","Len":6907,"Name":"ROS Navigation Stack","Permalink":"https://nuhuo08.github.io/navigation-stack/","Plain":"ROS系统结构 ROS Node ROS Node: 功能模块以Node的形式，处理某一特定的任务。    ROS Master: 记录所有现存的node，保证node之间的信息交流。parameter server运行在其中，实现参数与配置信息的共享。    ROS信息交互 单向通信：一个node发布topic，一个node订阅该topic    双向通信：一个node向另一个node发送信息并请求回复，使用service    查看ROS信息 rosnode list rostopic list rosservice list rostopic info /turtle1/cmd_vel rosmsg info geometry_msgs/Twist rqt_graph    ROS安装 ROS官网教程：ROS Tutorials\n安装ROS基本功能包 由于Ubuntu默认软件源在国内访问速度较慢，建议切换到阿里云。\n安装ROS：\nsudo sh -c \u0026#39;. /etc/lsb-release \u0026amp;\u0026amp; echo \u0026#34;deb http://mirrors.ustc.edu.cn/ros/ubuntu/ `lsb_release -cs` main\u0026#34; \u0026gt; /etc/apt/sources.list.d/ros-latest.list\u0026#39; sudo apt-key adv --keyserver \u0026#39;hkp://keyserver.ubuntu.com:80\u0026#39; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 sudo apt-get update sudo apt-get install ros-kinetic-desktop-full sudo rosdep init rosdep update echo \u0026#34;source /opt/ros/kinetic/setup.bash\u0026#34; \u0026gt;\u0026gt; ~/.bashrc source ~/.bashrc 由于Gazebo第一次打开时，需要联网下载模型，若网络太慢，Gazebo可能卡在启动页面一直不动。 建议手工下载Gazebo Models，并解压到/usr/share/gazebo-7/models路径下。\nIn virtual machine, Gazebo 7.0.0 doesn’t publish topic. We need to upgrade to Gazebo 7.11\nsudo sh -c \u0026#39;echo \u0026#34;deb http://packages.osrfoundation.org/gazebo/ubuntu-stable `lsb_release -cs` main\u0026#34; \u0026gt; /etc/apt/sources.list.d/gazebo-stable.list\u0026#39; wget http://packages.osrfoundation.org/gazebo.key -O - | sudo apt-key add - sudo apt-get update sudo apt-get install gazebo7 安装turtlebot导航包 When running VM on Win10, turn off hardware acceleration for 3D graphics. Otherwise Gazebo may crash.\n安装turtlebot导航包：\nsudo apt-get install ros-kinetic-turtlebot-* 导航包演示操作 Mapping 使用如下命令，可以打开Gazebo的仿真环境，看到Rviz的消息显示界面，后台的GMapping建图功能也已启动，只需要在Terminal中操作键盘，可以控制机器人在仿真环境中运动。\nroslaunch turtlebot_gazebo turtlebot_world.launch roslaunch turtlebot_gazebo gmapping_demo.launch roslaunch turtlebot_rviz_launchers view_navigation.launch roslaunch turtlebot_teleop keyboard_teleop.launch 建图完成后，通过如下命令保存建好的地图：\nmkdir ~/turtlebot_custom_maps rosrun map_server map_saver -f ~/turtlebot_custom_maps/tutorial Navigation 使用如下命令，将会启动AMCL定位功能。在Rviz中设定机器人的目标位置，结合上一步建成的地图，可以进行机器人导航。\nroslaunch turtlebot_gazebo turtlebot_world.launch roslaunch turtlebot_gazebo amcl_demo.launch map_file:=/home/user/turtlebot_custom_maps/tutorial.yaml roslaunch turtlebot_rviz_launchers view_navigation.launch 自定义机器人 Gazebo用作机器人的仿真环境，有丰富的教学资源。Gazebo Tutorials\n自定义两轮机器人 Make a Mobile Robot\n添加传感器 Creating a camera\n","PublishDate":"2020-01-09T08:00:00+08:00","ReadingTime":1,"RelPermalink":"/navigation-stack/","Section":"blog","Stat":{"IsDir":false,"ModTime":"2020-01-27T21:37:15.617073522+08:00","Mode":436,"Name":"index.md","Size":4058},"Tags":null,"Title":"ROS Navigation Stack","Type":"blog","Weight":0,"WordCount":187},{"Aliases":null,"File":{"BaseFileName":"index","ContentBaseName":"gmapping","Dir":"blog/ros/gmapping/","Ext":"md","Lang":"en","LogicalName":"index.md","Path":"blog/ros/gmapping/index.md","TranslationBaseName":"index","UniqueID":"1d37db947e20bbc87d9d330c3118963a"},"FuzzyWordCount":200,"GitInfo":{"hash":"701154c262422f11f8f133c8717c04c31e75eab1","abbreviatedHash":"701154c","subject":"add navigation-stack page","authorName":"nuhuo08","authorEmail":"845776955@qq.com","authorDate":"2020-01-27T21:52:13+08:00","commitDate":"2020-01-27T21:52:13+08:00"},"Kind":"page","Lastmod":"2020-01-27T21:52:13+08:00","Len":7861,"Name":"GMapping","Permalink":"https://nuhuo08.github.io/gmapping/","Plain":"基本理论 SLAM问题的分解 \\[ \\begin{aligned} p(x_{1:t},m|u_{1:t},z_{1:t}) \u0026= p(x_{1:t}|u_{1:t},z_{1:t}) p(m|u_{1:t},z_{1:t})\\\\ \u0026= p(x_{1:t}|u_{1:t},z_{1:t}) p(m|z_{1:t}) \\end{aligned} \\]\n将SLAM问题分解为：机器人的定位；基于已知机器人位姿的构图。\nFast-SLAM 根据贝叶斯公式，可以将机器人位姿的估计，转换成一个增量估计问题。\n\\[ \\begin{aligned} p(x_{1:t}|u_{1:t},z_{1:t}) \u0026= \\eta p(z_t|x_{1:t},u_{1:t},z_{1:t-1}) p(x_{1:t}|z_{1:t-1},u_{1,t})\\\\ \u0026= \\eta p(z_t|x_t) p(x_{1:t}|z_{1:t-1},u_{1:t})\\\\ \u0026= \\eta p(z_t|x_t) p(x_t|x_{1:t-1},z_{1:t-1},u_{1:t}) p(x_{1:t-1}|z_{1:t-1},u_{1:t})\\\\ \u0026= \\eta p(z_t|x_t) p(x_t|x_{t-1},u_{1:t}) p(x_{1:t-1}|z_{1:t-1},u_{1:t-1}) \\end{aligned} \\]\n其中，\\(p(x_{1:t-1}|z_{1:t-1},u_{1:t-1})\\)通过粒子群来表示； \\(p(x_t|x_{t-1},u_{1:t})\\)对每个粒子进行运动学模型的传播； \\(p(z_t|x_t)\\)根据观测模型计算权重。\n数据结构相关 Map template \u0026lt;class Cell, const bool debug=false\u0026gt; class Array2D{}; template \u0026lt;class Cell\u0026gt; class HierarchicalArray2D: public Array2D\u0026lt;autoptr\u0026lt; Array2D\u0026lt;Cell\u0026gt; \u0026gt; \u0026gt;{}; template \u0026lt;class Cell, class Storage, const bool isClass=true\u0026gt; class Map{}; typedef Map\u0026lt;PointAccumulator,HierarchicalArray2D\u0026lt;PointAccumulator\u0026gt; \u0026gt; ScanMatcherMap;  Array2D是一个二维数组，HierarchicalArray2D是一个Array2D的二维数组。 相当于将地图先分割成分辨率比较低的网格，只有当粒子运动到该网格时，才真正分配这个网格的内存。 网格的内存对应着分辨率高的真实的地图，用PointAccumulator来进行计数，记录激光是否通过该点，从而判断改点的状态：占据、空闲、未知。\nautoptr GMapping中自己实现了autoptr类，实现了智能指针的功能。\n运动更新 根据上一时刻的状态，结合里程计的输入量，可以得到当前时刻预估的状态。\n\\[ x_t = g_t(u_t, x_{t-1}) + \\varepsilon_t \\]\n权重计算 光束模型    使用Bresenham画线算法，进行高效的计算。 由于计算量过大、在非结构化环境中得分会突变，因此实际工程项目中很少采用此方法。\n\\[ p(z_t^k|x_t,m)=\\begin{pmatrix} z_{hit} \\\\ z_{short} \\\\ z_{max} \\\\ z_{rand} \\end{pmatrix}^T \\begin{pmatrix} p_{hit}(z_t^k|x_t,m) \\\\ p_{short}(z_t^k|x_t,m) \\\\ p_{max}(z_t^k|x_t,m) \\\\ p_{rand}(z_t^k|x_t,m) \\end{pmatrix} \\]\n似然场模型    对图像进行高斯平滑，不会出现得分突变的情况，且运算效率高，查表即可得到。是工程项目中常用的方法。\n重采样优化 里程计扩散出来的最好的粒子 若里程计信号质量误差较大，则需要大量粒子对验后分布进行模拟。由于每个粒子都携带一个地图，这将会造成巨大的内存消耗。 根据里程计的运动模型，每个粒子会扩散出很多粒子。从其中找出最好的那个粒子，其他的全去除，可以大量减少粒子数量。\n\\[ x_t^i \\sim p(x_t|u_t,x_{t-1}^i) \\\\[2mm] \\to x_t^i = \\arg \\max_{x_t}(p(z_t|x_t,m)p(x_t|u_t,x_{t-1}^i)) \\]\n抑制重采样次数 当采样次数过多时，会出现粒子耗散问题，即所有的粒子来自于少数几个粒子。\n\\[ N_{eff} = \\frac{1}{\\sum_{i = 1}^N \\left(\\tilde{w}^{(i)} \\right)^2} \\]\n当\\(N_{eff}\\)较大时，说明各粒子的差异性较小，此时不要进行重采样。反之，则应进行重采样。\n根据激光匹配估计出分布 由于激光的精度较高，可以通过激光的匹配，估计出一个高斯分布。并在此分布中进行采样，得到一系列粒子。\n建图算法 覆盖栅格建图 \\[ l(m_i|x_{1:t},z_{1:t})=l(m_i|x_t,z_t)+l(m_i|x_{1:t-1},z_{1:t-1})-l(m_i) \\]\n其中，\\(l(m_i|x_t,z_t)\\)表示会激光雷达的逆观测模型；\\(l(m_i|x_{1:t-1},z_{1:t-1})\\)表示栅格\\(m_i\\)在\\(t-1\\)时刻的状态， \\(l(m_i)\\)表示栅格\\(m_i\\)的先验值，对所有栅格都相同。\n计数建图法 \\[ m_j = \\frac{a_j}{a_j+b_j} \\]\n其中，\\(a_j\\)表示击中的次数，\\(b_j\\)表示未击中的次数。\n","PublishDate":"2020-01-08T08:00:00+08:00","ReadingTime":1,"RelPermalink":"/gmapping/","Section":"blog","Stat":{"IsDir":false,"ModTime":"2020-01-28T00:51:47.568168046+08:00","Mode":436,"Name":"index.md","Size":4343},"Tags":null,"Title":"GMapping","Type":"blog","Weight":0,"WordCount":160},{"Aliases":null,"File":{"BaseFileName":"index","ContentBaseName":"slam-for-dummies","Dir":"blog/slam/slam-for-dummies/","Ext":"md","Lang":"en","LogicalName":"index.md","Path":"blog/slam/slam-for-dummies/index.md","TranslationBaseName":"index","UniqueID":"7b130c73d29bcc9f4f898e3e9e0e2917"},"FuzzyWordCount":300,"GitInfo":{"hash":"701154c262422f11f8f133c8717c04c31e75eab1","abbreviatedHash":"701154c","subject":"add navigation-stack page","authorName":"nuhuo08","authorEmail":"845776955@qq.com","authorDate":"2020-01-27T21:52:13+08:00","commitDate":"2020-01-27T21:52:13+08:00"},"Kind":"page","Lastmod":"2020-01-27T21:52:13+08:00","Len":1949,"Name":"SLAM for Dummies","Permalink":"https://nuhuo08.github.io/slam-for-dummies/","Plain":"TO BE CONTINUED\nhttps://zhuanlan.zhihu.com/p/32937247\n观测方程 \\[ \\underbrace{\\begin{pmatrix} r_1 \\\\ \\theta_1 \\\\ r_2 \\\\ \\theta_2 \\\\ \\vdots \\\\ r_n \\\\ \\theta_n \\end{pmatrix}}_Z = \\underbrace{\\begin{bmatrix} A_1 \u0026B_1 \u0026C_1 \u0026-A_1 \u0026-B_1 \\\\ D_1 \u0026E_1 \u0026F_1 \u0026-D_1 \u0026-E_1 \\\\ A_2 \u0026B_2 \u0026C_2 \u0026 \u0026 \u0026-A_2 \u0026-B_2 \\\\ D_2 \u0026E_2 \u0026F_2 \u0026 \u0026 \u0026-D_2 \u0026-E_2 \\\\ \u0026\\vdots \u0026 \u0026 \u0026 \u0026 \u0026 \u0026 \\ddots \\\\ A_n \u0026B_n \u0026C_n \u0026 \u0026 \u0026 \u0026 \u0026 \u0026-A_n \u0026-B_n \\\\ D_n \u0026E_n \u0026F_n \u0026 \u0026 \u0026 \u0026 \u0026 \u0026-D_n \u0026-E_n \\\\ \\end{bmatrix}}_H \\underbrace{\\begin{pmatrix} x_r \\\\ y_r \\\\ \\theta_r \\\\ x_1 \\\\ y_1 \\\\ x_2 \\\\ y_2 \\\\ \\vdots \\\\ x_n \\\\ y_n \\end{pmatrix}}_X \\\\[2mm] R = \\begin{pmatrix} r_c \u0026 \\\\ \u0026r_d \\end{pmatrix} \\]\n动态方程 \\[ \\underbrace{\\begin{pmatrix} x_r \\\\ y_r \\\\ \\theta_r \\end{pmatrix}}_{X_{k+1}} = \\underbrace{\\begin{bmatrix} 1 \u0026 \u0026-\\Delta y \\\\ \u00261 \u0026\\Delta x \\\\ \u0026 \u00261\\end{bmatrix}}_A \\underbrace{\\begin{pmatrix} x_r \\\\ y_r \\\\ \\theta_r \\end{pmatrix}}_{X_k} \\\\[2mm] Q = \\begin{pmatrix} c\\Delta x^2 \\\\ \u0026 c\\Delta y^2 \\\\ \u0026 \u0026c\\Delta t^2\\end{pmatrix} \\]\n新增路标点的协方差矩阵增广 landmark wrt. robot state \\[ J_{xr} = \\begin{bmatrix} 1 \u0026 \u0026-\\Delta y \\\\ \u00261 \u0026\\Delta x\\end{bmatrix} \\]\nlandmark wrt. [range, bearing] \\[ J_z = \\begin{bmatrix} \\cos(\\theta + \\Delta \\theta) \u0026-\\Delta t \\cdot \\sin(\\theta + \\Delta \\theta) \\\\ \\sin(\\theta + \\Delta \\theta) \u0026\\Delta t \\cdot \\cos(\\theta + \\Delta \\theta) \\end{bmatrix} \\]\ncovariance \\[ P^{r \\ {N+1}} = P^{rr}J_{xr}^T \\\\[2mm] P^{i \\ {N+1}} = P^{ri}J_{xr}^T \\\\[2mm] P^{{N+1} \\ {N+1}} = J_{xr}PJ_{xr}^T + J_zRJ_z^T \\]\n","PublishDate":"2020-01-07T08:00:00+08:00","ReadingTime":2,"RelPermalink":"/slam-for-dummies/","Section":"blog","Stat":{"IsDir":false,"ModTime":"2020-01-26T13:29:24.332568402+08:00","Mode":436,"Name":"index.md","Size":1615},"Tags":null,"Title":"SLAM for Dummies","Type":"blog","Weight":0,"WordCount":231},{"Aliases":null,"File":{"BaseFileName":"index","ContentBaseName":"non-linear","Dir":"blog/math/non-linear/","Ext":"md","Lang":"en","LogicalName":"index.md","Path":"blog/math/non-linear/index.md","TranslationBaseName":"index","UniqueID":"c83b266721ff9902afb2091ebb79eb13"},"FuzzyWordCount":300,"GitInfo":{"hash":"7e7a2000c988b2460dc5b2136847965e9905fdd8","abbreviatedHash":"7e7a200","subject":"1. add matrix page 2. add factor-graph page","authorName":"nuhuo08","authorEmail":"845776955@qq.com","authorDate":"2020-01-28T00:53:30+08:00","commitDate":"2020-01-28T00:53:30+08:00"},"Kind":"page","Lastmod":"2020-01-28T00:53:30+08:00","Len":5675,"Name":"Non-Linear","Permalink":"https://nuhuo08.github.io/non-linear/","Plain":"优化方法比较    方法 特点     梯度下降法 \\(x_{i+1}=x_i-\\eta \\frac{\\partial f}{\\partial x}\\)，效率高，但可能收敛慢   牛顿法 二阶泰勒展开，计算Hessian矩阵耗时，离初值远不收敛，极小值处接近二次函数   高斯-牛顿法 仅适用于最小二乘问题，以Jacobian矩阵\\(J^TJ\\)代替\\(H\\)，离初值远不收敛，\\(J^TJ\\)近奇异不收敛   L-M法 \\(\\left(H+\\lambda I\\right)\\Sigma=-J^Tr\\)，残差增大时，放大\\(\\lambda\\)，成为梯度下降；残差减小时，减小\\(\\lambda\\)，成为高斯-牛顿    g2o g2o在ORB-SLAM2中的用法 Ceres http://ceres-solver.org/nnls_modeling.html\n对于以下代价函数：\n\\[ \\frac{1}{2} \\sum_i \\rho_i(\\parallel f_i(x_{i1}, x_{i2}, \\cdots, x_{ik}) \\parallel ^2) \\]\n在Ceres中，\\(\\rho\\)为loss function，用于减弱外点的影响；\\(f\\)为cost function，定义了残差的计算方式；\\((x_{i1}, x_{i2}, \\cdots, x_{ik})\\)为parameter block，定义了需要估计的变量；\\(\\rho_i(\\parallel f_i(x_{i1}, x_{i2}, \\cdots, x_{ik}) \\parallel ^2)\\)为residual block，定义了一个残差块。\nAddResidualBlock problem.AddResidualBlock(costfunction, lossfunction, x1, x2 ... xn)\n其中，\\(x_1, x_2, \\cdots x_n\\)要与costfunction中的变量维数要对应起来。\ncostfunction有两种典型的定义方式：\n 自己实现残差、雅可比  templateclass SizedCostFunction : public CostFunction { public: virtual bool Evaluate(double const* const* parameters, double* residuals, double** jacobians) const = 0; }; 这种情况下，需要指定残差维数、参数块维数，并自己实现Evaluate()，计算cost和jacobian。\n自己实现残差即可  template class AutoDiffCostFunction : public SizedCostFunction{ public: explicit AutoDiffCostFunction(CostFunctor* functor); // Ignore the template parameter kNumResiduals and use // num_residuals instead. AutoDiffCostFunction(CostFunctor* functor, int num_residuals); }; 这种情况下，不再需要自己计算jacobian。只需要定义CostFunctor，计算残差，实现operator()函数。例如：\nclass MyScalarCostFunctor { MyScalarCostFunctor(double k): k_(k) {} template bool operator()(const T* const x , const T* const y, T* e) const { e[0] = k_ - x[0] * y[0] - x[1] * y[1]; return true; } private: double k_; }; AddParameterBlock ceres::LocalParameterization *local_parameterization = new PoseLocalParameterization(); problem.AddParameterBlock(para_Pose[i], SIZE_POSE, local_parameterization); problem.AddParameterBlock(para_SpeedBias[i], SIZE_SPEEDBIAS); Sometimes the parameters \\(x\\) can overparameterize a problem. In that case it is desirable to choose a parameterization to remove the null directions of the cost.\nCeres在VINS-MONO中的用法 Factor VINS 中用 IMUFactor 表示 IMU 的 cost function，用 ProjectionFactor 表示图像重投影误差的 cost function。其中定义了对各个参数块的残差、雅可比。\nMarginalizationFactor 表达了先验残差的更新方式。在Evaluate()函数中，实现了如下更新： \nResidualBlockInfo 为了进行 Schur，在 cost function 外面包了一层 ResidualBlockInfo。因为在原生Ceres中，一旦调用 problem.AddResidualBlock(costfunction, lossfunction, x1, x2 ... xn)，便不再能干预内部处理流程。\n在这个自定义的 ResidualBlockInfo 的 Evaluate() 中，调用了每个 cost function 原生的 Evaluate()，获得残差、雅可比，然后将 loss function 的功能也在此调用，组装好以后，留给 MarginalizationInfo 做进一步处理。\nMarginalizationInfo addResidualBlockInfo() 处理优化变量、待边缘化变量\npreMarginalize()\nmarginalize() 并行化线程，进行舒尔补计算\n","PublishDate":"2020-01-06T08:00:00+08:00","ReadingTime":2,"RelPermalink":"/non-linear/","Section":"blog","Stat":{"IsDir":false,"ModTime":"2020-01-27T23:29:32.543851494+08:00","Mode":436,"Name":"index.md","Size":4927},"Tags":null,"Title":"Non-Linear","Type":"blog","Weight":0,"WordCount":234},{"Aliases":null,"File":{"BaseFileName":"index","ContentBaseName":"vins-mono","Dir":"blog/slam/vins-mono/","Ext":"md","Lang":"en","LogicalName":"index.md","Path":"blog/slam/vins-mono/index.md","TranslationBaseName":"index","UniqueID":"0c4a8ac17f16aede809877d1eac1a13f"},"FuzzyWordCount":500,"GitInfo":{"hash":"701154c262422f11f8f133c8717c04c31e75eab1","abbreviatedHash":"701154c","subject":"add navigation-stack page","authorName":"nuhuo08","authorEmail":"845776955@qq.com","authorDate":"2020-01-27T21:52:13+08:00","commitDate":"2020-01-27T21:52:13+08:00"},"Kind":"page","Lastmod":"2020-01-27T21:52:13+08:00","Len":10286,"Name":"VINS-MONO","Permalink":"https://nuhuo08.github.io/vins-mono/","Plain":"代码流程图    动态方程 预积分公式推导 \\(b_k^a\\)和\\(b_k^g\\)作为随机游走噪声，在推导\\(k \\sim k+1\\)时认为是常数！不像\\(w\\)和\\(a\\)，要添加\\(n_k^g\\)和\\(n_k^a\\)噪声进去\n\\[ \\omega=\\frac{1}{2}( (\\omega^{b_k}+n_k^g-b_k^g) + (\\omega^{b_{k+1}}+n_{k+1}^g-b_k^g) ) \\\\[2mm] q_{b_ib_{k+1}}=q_{b_ib_k}\\otimes\\begin{bmatrix}1 \\\\ \\frac{1}{2}\\omega\\delta{t}\\end{bmatrix} \\\\[2mm] a=\\frac{1}{2}( q_{b_ib_k}(a^{b_k}+n_k^a-b_k^a) + q_{b_ib_{k+1}}(a^{b_{k+1}}+n_{k+1}^a-b_k^a) ) \\\\[2mm] \\beta_{b_ib_{k+1}}=\\beta_{b_ib_k}+a\\delta{t} \\\\[2mm] \\alpha_{b_ib_{k+1}}=\\alpha_{b_ib_k}+\\beta_{b_ib_k}\\delta{t}+\\frac{1}{2}a\\delta{t}^2 \\\\[2mm] b_{k+1}^a=b_k^a+n_{b_k^a}\\delta{t} \\\\[2mm] b_{k+1}^g=b_k^g+n_{b_k^g}\\delta{t} \\\\[2mm] \\]\n写成矩阵形式：\n\\[ \\begin{bmatrix}\\alpha_{b_ib_{k+1}} \\\\ \\theta_{b_ib_{k+1}} \\\\ \\beta_{b_ib_{k+1}} \\\\ b_{k+1}^a \\\\ b_{k+1}^g\\end{bmatrix} =F*\\begin{bmatrix}\\alpha_{b_ib_{k}} \\\\ \\theta_{b_ib_{k}} \\\\ \\beta_{b_ib_{k}} \\\\ b_{k}^a \\\\ b_{k}^g\\end{bmatrix} +G*\\begin{bmatrix}n_k^a \\\\ n_k^g \\\\ n_{k+1}^a \\\\ n_{k+1}^g \\\\ n_{k}^a \\\\ n_{k}^g \\end{bmatrix} \\]\n\\[ F=\\begin{bmatrix}I \u0026f_{12} \u0026I\\delta{t} \u0026-\\frac{1}{4}(q_{b_ib_k}+q_{b_ib_{k+1}})\\delta{t}^2 \u0026f_{15}\\\\ 0 \u0026I-[\\omega]_{\\times} \u00260 \u00260 \u0026-I\\delta{t}\\\\ 0 \u0026f_{32} \u0026I \u0026-\\frac{1}{2}(q_{b_ib_k}+q_{b_ib_{k+1}})\\delta{t} \u0026f_{35}\\\\ 0 \u00260 \u00260 \u0026I \u00260\\\\ 0 \u00260 \u00260 \u00260 \u0026I \\end{bmatrix} \\\\[2mm] G=\\begin{bmatrix}\\frac{1}{4}q_{b_ib_k}\\delta{t}^2 \u0026g_{12} \u0026\\frac{1}{4}q_{b_ib_{k+1}}\\delta{t}^2 \u0026g_{14} \u00260 \u00260 \\\\ 0 \u0026\\frac{1}{2}I\\delta{t} \u00260 \u0026\\frac{1}{2}I\\delta{t} \u00260 \u00260\\\\ \\frac{1}{2}q_{b_ib_k}\\delta{t} \u0026g_{32} \u0026\\frac{1}{2}q_{b_ib_{k+1}}\\delta{t} \u0026g_{34} \u00260 \u00260\\\\ 0 \u00260 \u00260 \u00260 \u0026I\\delta{t} \u00260\\\\ 0 \u00260 \u00260 \u00260 \u00260 \u0026I\\delta{t}\\end{bmatrix} \\\\[2mm] f_{12}=-\\frac{1}{4}( R_{b_ib_k}[a^{b_k}-b_k^a]_\\times\\delta{t}^2 + R_{b_ib_{k+1}}[a^{b_{k+1}}-b_k^a]_\\times(I-[\\omega]_\\times\\delta{t})\\delta{t}^2) \\\\[2mm] f_{32}=-\\frac{1}{2}( R_{b_ib_k}[a^{b_k}-b_k^a]_\\times\\delta{t} + R_{b_ib_{k+1}}[a^{b_{k+1}}-b_k^a]_\\times(I-[\\omega]_\\times\\delta{t})\\delta{t}) \\\\[2mm] f_{15}=-\\frac{1}{4}(R_{b_ib_{k+1}}[a^{b_{k+1}}-b_k^a]_\\times\\delta{t}^2)(-\\delta{t}) \\\\[2mm] f_{35}=-\\frac{1}{2}(R_{b_ib_{k+1}}[a^{b_{k+1}}-b_k^a]_\\times\\delta{t})(-\\delta{t}) \\\\[2mm] g_{12}=g_{14}=-\\frac{1}{4}(R_{b_ib_{k+1}}[a^{b_{k+1}}-b_k^a]_\\times\\delta{t}^2)(\\frac{1}{2}\\delta{t}) \\\\[2mm] g_{32}=g_{34}=-\\frac{1}{2}(R_{b_ib_{k+1}}[a^{b_{k+1}}-b_k^a]_\\times\\delta{t})(\\frac{1}{2}\\delta{t}) \\]\n终极大矩阵 将所有值带进去并展开，得到原始等式\n\\[ q_{b_ib_{k+1}}=q_{b_ib_k}\\otimes\\begin{bmatrix}1 \\\\ \\frac{1}{2}\\{\\frac{1}{2}( (\\omega^{b_k}+n_k^g-b_k^g) + (\\omega^{b_{k+1}}+n_{k+1}^g-b_k^g) )\\}\\delta{t}\\end{bmatrix} \\\\[2mm] \\beta_{b_ib_{k+1}}=\\beta_{b_ib_k}+\\{\\frac{1}{2}( q_{b_ib_k}(a^{b_k}+n_k^a-b_k^a) + \\{q_{b_ib_k}\\otimes\\begin{bmatrix}1 \\\\ \\frac{1}{2}\\{\\frac{1}{2}( (\\omega^{b_k}+n_k^g-b_k^g) + (\\omega^{b_{k+1}}+n_{k+1}^g-b_k^g) )\\}\\delta{t}\\end{bmatrix}\\}(a^{b_{k+1}}+n_{k+1}^a-b_k^a) )\\}\\delta{t} \\\\[2mm] \\alpha_{b_ib_{k+1}}=\\alpha_{b_ib_k}+\\beta_{b_ib_k}\\delta{t}+\\frac{1}{2}\\{\\frac{1}{2}( q_{b_ib_k}(a^{b_k}+n_k^a-b_k^a) + \\{q_{b_ib_k}\\otimes\\begin{bmatrix}1 \\\\ \\frac{1}{2}\\{\\frac{1}{2}( (\\omega^{b_k}+n_k^g-b_k^g) + (\\omega^{b_{k+1}}+n_{k+1}^g-b_k^g) )\\}\\delta{t}\\end{bmatrix}\\}(a^{b_{k+1}}+n_{k+1}^a-b_k^a) )\\}\\delta{t}^2 \\\\[2mm] b_{k+1}^a=b_k^a+n_{b_k^a}\\delta{t} \\\\[2mm] b_{k+1}^g=b_k^g+n_{b_k^g}\\delta{t} \\]\n矩阵形式\n\\[ \\begin{bmatrix}\\alpha_{b_ib_{k+1}} \\\\ \\theta_{b_ib_{k+1}} \\\\ \\beta_{b_ib_{k+1}} \\\\ b_{k+1}^a \\\\ b_{k+1}^g\\end{bmatrix} =\\begin{bmatrix}I \u0026-\\frac{1}{4}( R_{b_ib_k}[a^{b_k}-b_k^a]_\\times\\delta{t}^2 + R_{b_ib_{k+1}}[a^{b_{k+1}}-b_k^a]_\\times(I-[\\omega]_\\times\\delta{t})\\delta{t}^2) \u0026I\\delta{t} \u0026-\\frac{1}{4}(q_{b_ib_k}+q_{b_ib_{k+1}})\\delta{t}^2 \u0026-\\frac{1}{4}(R_{b_ib_{k+1}}[a^{b_{k+1}}-b_k^a]_\\times\\delta{t}^2)(-\\delta{t})\\\\ 0 \u0026I-[\\omega]_{\\times} \u00260 \u00260 \u0026-I\\delta{t}\\\\ 0 \u0026-\\frac{1}{2}( R_{b_ib_k}[a^{b_k}-b_k^a]_\\times\\delta{t} + R_{b_ib_{k+1}}[a^{b_{k+1}}-b_k^a]_\\times(I-[\\omega]_\\times\\delta{t})\\delta{t}) \u0026I \u0026-\\frac{1}{2}(q_{b_ib_k}+q_{b_ib_{k+1}})\\delta{t} \u0026-\\frac{1}{2}(R_{b_ib_{k+1}}[a^{b_{k+1}}-b_k^a]_\\times\\delta{t})(-\\delta{t})\\\\ 0 \u00260 \u00260 \u0026I \u00260\\\\ 0 \u00260 \u00260 \u00260 \u0026I \\end{bmatrix} *\\begin{bmatrix}\\alpha_{b_ib_{k}} \\\\ \\theta_{b_ib_{k}} \\\\ \\beta_{b_ib_{k}} \\\\ b_{k}^a \\\\ b_{k}^g\\end{bmatrix}\\\\ +\\begin{bmatrix}\\frac{1}{4}q_{b_ib_k}\\delta{t}^2 \u0026-\\frac{1}{4}(R_{b_ib_{k+1}}[a^{b_{k+1}}-b_k^a]_\\times\\delta{t}^2)(\\frac{1}{2}\\delta{t}) \u0026\\frac{1}{4}q_{b_ib_{k+1}}\\delta{t}^2 \u0026-\\frac{1}{4}(R_{b_ib_{k+1}}[a^{b_{k+1}}-b_k^a]_\\times\\delta{t}^2)(\\frac{1}{2}\\delta{t}) \u00260 \u00260 \\\\ 0 \u0026\\frac{1}{2}I\\delta{t} \u00260 \u0026\\frac{1}{2}I\\delta{t} \u00260 \u00260\\\\ \\frac{1}{2}q_{b_ib_k}\\delta{t} \u0026-\\frac{1}{2}(R_{b_ib_{k+1}}[a^{b_{k+1}}-b_k^a]_\\times\\delta{t})(\\frac{1}{2}\\delta{t}) \u0026\\frac{1}{2}q_{b_ib_{k+1}}\\delta{t} \u0026-\\frac{1}{2}(R_{b_ib_{k+1}}[a^{b_{k+1}}-b_k^a]_\\times\\delta{t})(\\frac{1}{2}\\delta{t}) \u00260 \u00260\\\\ 0 \u00260 \u00260 \u00260 \u0026I\\delta{t} \u00260\\\\ 0 \u00260 \u00260 \u00260 \u00260 \u0026I\\delta{t}\\end{bmatrix} *\\begin{bmatrix}n_k^a \\\\ n_k^g \\\\ n_{k+1}^a \\\\ n_{k+1}^g \\\\ n_{k}^a \\\\ n_{k}^g \\end{bmatrix} \\]\n观测方程 相机 观测方程：\n\\[ P_{w_l}=R_{b_i}^w(R_c^b\\frac{1}{\\lambda_l}\\pi_c^{-1}(\\begin{bmatrix}\\mu_l^{c_i}\\\\\\nu_l^{c_i}\\end{bmatrix})+p_c^b)+p_{b_i}^w \\\\[2mm] P_{w_l}=R_{b_j}^w(R_c^bP_l^{c_j}+p_c^b)+p_{b_j}^w \\\\[2mm] P_l^{c_j}=R_b^c\\{R_w^{b_j}[R_{b_i}^w(R_c^b\\frac{1}{\\lambda_l}\\overline{P}_l^{c_i}+p_c^b)+p_{b_i}^w-p_{b_j}^w]-p_c^b\\} \\]\n转换成矩阵形式：\n\\[ P_l^{c_j}=\\begin{bmatrix} R_b^cR_w^{b_j} \\\\ -R_b^cR_w^{b_j}R_{b_i}^w(R_c^b\\frac{1}{\\lambda_l}\\overline{P}_l^{c_i}+p_c^b)^{\\wedge} \\\\ -R_b^cR_w^{b_j} \\\\ R_b^c\\{R_w^{b_j}[R_{b_i}^w(R_c^b\\frac{1}{\\lambda_l}\\overline{P}_l^{c_i}+p_c^b)+p_{b_i}^w-p_{b_j}^w]\\}^\\wedge \\\\ R_b^c(R_w^{b_j}R_{b_i}^w-I_{3\\times3}) \\\\ -R_b^cR_w^{b_j}R_{b_i}^wR_c^b(\\frac{1}{\\lambda_l}\\overline{P}_l^{c_i})^{\\wedge}+(R_b^cR_w^{b_j}R_{b_i}^wR_c^b\\frac{1}{\\lambda_l}\\overline{P}_l^{c_i})^{\\wedge}+\\{R_b^c[R_w^{b_j}(R_{b_i}^wp_c^b+p_{b_i}^w-p_{b_j}^w)-p_c^b]\\}^{\\wedge} \\\\ -R_b^cR_w^{b_j}R_{b_i}^wR_c^b\\frac{1}{\\lambda_l^2}\\overline{P}_l^{c_i} \\end{bmatrix}^T *\\begin{bmatrix} p_{b_i}^w \\\\ q_{b_i}^w \\\\ p_{b_j}^w \\\\ q_{b_j}^w \\\\ p_c^b \\\\ q_c^b \\\\ \\lambda_l \\end{bmatrix} \\]\nIMU 观测方程：\n\\[ \\gamma_B=\\begin{bmatrix} R_w^{b_k}(p_{b_{k+1}}^w-p_{b_k}^w-\\nu_{b_k}^w\\Delta{t_k}+\\frac{1}{2}g^w\\Delta{t_k^2})-\\alpha_{b_{k+1}}^{b_k} \\\\ 2[\\gamma_{b_{k+1}}^{b_k}{\\otimes}{q_{b_k}^w}^{-1}\\otimes{q_{b_{k+1}}^w}] \\\\ R_w^{b_k}(\\nu_{b_{k+1}}^w-\\nu_{b_k}^w+g^w\\Delta{t_k})-\\beta_{b_{k+1}}^{b_k} \\\\ b_{a_{b_{k+1}}}-b_{a_{b_k}} \\\\ b_{\\omega_{b_{k+1}}}-b_{\\omega_{b_k}} \\end{bmatrix} \\]\n转换成矩阵形式：\n\\[ \\gamma_B=\\begin{bmatrix} -R_w^{b_k} \u00260 \u00260 \u00260 \u00260 \\\\ [R_w^{b_k}(p_{b_{k+1}}^w-p_{b_k}^w-\\nu_{b_k}^w\\Delta{t_k}+\\frac{1}{2}g^w\\Delta{t_k^2})]^\\wedge \u0026-\\mathcal{L}[{q_{b_{k+1}}^w}^{-1}\\otimes{q_{b_k}^w}]\\mathcal{R}[\\gamma_{b_{k+1}}^{b_k}] \u0026[R_w^{b_k}(\\nu_{b_{k+1}}^w-\\nu_{b_k}^w+g^w\\Delta{t_k})]^\\wedge \u00260 \u00260\\\\ -R_w^{b_k}\\Delta{t} \u00260 \u0026-R_w^{b_k} \u00260 \u00260\\\\ -\\mathcal{J}_{b_a}^\\alpha \u00260 \u0026-\\mathcal{J}_{b_a}^\\beta \u0026-I \u00260 \\\\ -\\mathcal{J}_{b_\\omega}^\\alpha \u0026-\\mathcal{L}[{q_{b_{k+1}}^w}^{-1}\\otimes{q_{b_k}^w}\\otimes\\gamma_{b_{k+1}}^{b_k}]\\mathcal{J}_{b_\\omega}^\\gamma \u0026-\\mathcal{J}_{b_\\omega}^\\beta \u00260 \u0026-I \\\\ R_w^{b_k} \u00260 \u00260 \u00260 \u00260 \\\\ 0 \u0026\\mathcal{L}[{\\gamma_{b_{k+1}}^{b_k}}^{-1}\\otimes{q_{b_{k}}^w}^{-1}\\otimes{q_{b_{k+1}}^w}] \u00260 \u00260 \u00260\\\\ 0 \u00260 \u0026R_w^{b_k} \u00260 \u00260\\\\ 0 \u00260 \u00260 \u0026I \u00260\\\\ 0 \u00260 \u00260 \u00260 \u0026I \\end{bmatrix}^T *\\begin{bmatrix} p_{b_k}^w \\\\ q_{b_k}^w \\\\ v_{b_k}^w \\\\ b_{a_k} \\\\ b_{\\omega_k} \\\\ p_{b_{k+1}}^w \\\\ q_{b_{k+1}}^w \\\\ v_{b_{k+1}}^w \\\\ b_{a_{k+1}} \\\\ b_{\\omega_{k+1}} \\end{bmatrix} \\]\n在线标定 求解 使方程满秩可求解 信息矩阵 \\(H\\) 不满秩\n 用LM方法求解，会导致H满秩 --\u0026gt; 解在空间中整体变化 添加先验约束，增加系统可观性。例如固定第一个相机，\\(H_{[11]}+=I\\) 添加超强先验，使得对应的信息矩阵巨大\\(H_{[11]}=\\infty\\)，就能使得\\(\\Delta{x}=H^{-1}b=0\\) 设定对应雅克比矩阵为 0，则\\(H_{[11]}=0\\)，\\(b_{[1]}=0\\)。则在求解时，\\((0+\\lambda{I})\\Delta{x}=0\\)  舒尔补    更新先验残差 \\[ b_p^{'}=b_p+\\frac{\\partial{b_p}}{\\partial{x_p}}\\delta{x_p}\\\\ =b_p+\\frac{\\partial{(-J^T\\Sigma^{-1}r)}}{\\partial{x_p}}\\delta{x_p}\\\\ =b_p-\\Lambda_p\\delta{x_p} \\]\nCeres在VINS-MONO中的使用 Ceres的具体用法，及其在VINS-MONO中的用法，请参考如下文章： non-linear\n","PublishDate":"2020-01-05T08:00:00+08:00","ReadingTime":3,"RelPermalink":"/vins-mono/","Section":"blog","Stat":{"IsDir":false,"ModTime":"2020-01-26T11:22:35.56548329+08:00","Mode":436,"Name":"index.md","Size":8740},"Tags":null,"Title":"VINS-MONO","Type":"blog","Weight":0,"WordCount":439},{"Aliases":null,"File":{"BaseFileName":"index","ContentBaseName":"orb-slam2","Dir":"blog/slam/orb-slam2/","Ext":"md","Lang":"en","LogicalName":"index.md","Path":"blog/slam/orb-slam2/index.md","TranslationBaseName":"index","UniqueID":"750d5dc9106c12cc575da461ae8af27a"},"FuzzyWordCount":600,"GitInfo":{"hash":"701154c262422f11f8f133c8717c04c31e75eab1","abbreviatedHash":"701154c","subject":"add navigation-stack page","authorName":"nuhuo08","authorEmail":"845776955@qq.com","authorDate":"2020-01-27T21:52:13+08:00","commitDate":"2020-01-27T21:52:13+08:00"},"Kind":"page","Lastmod":"2020-01-27T21:52:13+08:00","Len":13202,"Name":"ORB-SLAM2","Permalink":"https://nuhuo08.github.io/orb-slam2/","Plain":"Tracking Initialization SearchForInitialization --\u0026gt; Initialize(RANSAC) --\u0026gt; GlobalBundleAdjustemnt --\u0026gt; ComputeSceneMedianDepth\nSearchForInitialization:\nGetFeaturesInArea --\u0026gt; DescriptorDistance --\u0026gt; ComputeThreeMaxima\nORB特征\nOriented FAST关键点：\n 比较像素点周围圆上的像素间亮度的差异 非极大值抑制，在一定区域内仅保留响应极大值的角点，避免太集中 对角点计算Harris响应值，仅保留前N个具有最大响应值的角点 构建金字塔，在金字塔每一层检测角点。实现尺度不变 灰度质心法，连接图像块的几何中心与质心。实现旋转不变  BRIEF描述子：\n 随机选点并比较灰度，组成128维的二进制数组 使用Hamming distance作为度量，即不同位数的个数  F矩阵\nhttps://zhuanlan.zhihu.com/p/61614421\n在求解F和H矩阵之前，应该首先进行特征点归一化，保证坐标均值为0，一阶绝对矩为1。(MVG P67，归一化才能消除坐标变换的影响)\n设\\(p1\\)，\\(p2\\)为像素坐标，可知：\n\\[ p_2 = K (RP + t) \\\\[2mm] p_1 = KP \\]\n从上述\\(p1\\)，\\(p2\\)的关系式出发，导出：\n\\[ (K^{-1} p_2)^T t^{\\wedge} K^{-1} p_2 = 0 = p_2^T K^{-T} t^{\\wedge} R K^{-1} p_1 = p_2^T F p_1 \\]\n一对匹配的像素点可以写1个方程，考虑到尺度等价性，使用八点法即可求解\\(F\\)矩阵。\nTODO: 由基础矩阵F分解出R和t\n多余的话\nopencv中，cv::findFundamentalMat()如果选择8点法，则是直接将所有点进行最小二乘计算，没有外点剔除功能。\nhttps://stackoverflow.com/questions/25251676/opencv-findfundamentalmat-very-unstable-and-sensitive/48394798\nH矩阵\n平面方程为：\n\\[ aX + bY + cZ + d = 0 \\\\[2mm] -\\frac{n^TP}{d} = -1 \\]\n依旧从\\(p1\\)，\\(p2\\)的关系式出发，导出：\n\\[ p_2 = K (RP + t \\cdot (-\\frac{n^TP}{d})) = K (R - \\frac{tn^T}{d}) K^{-1} p_1 = Hp_1 \\]\n一对匹配的像素点可以写2个方程，因此4对匹配特征点即可求解\\(H\\)矩阵。\nTODO: 由单应矩阵H恢复出R和t\nF与H的评分\n\\[ S_M = \\sum_i\\{ \\rho_M\\left(d_{cr}^2\\left(x_c^i,x_r^i,M\\right)\\right)+ \\rho_M\\left(d_{rc}^2\\left(x_c^i,x_r^i,M\\right)\\right) \\} \\\\[2mm] \\rho_M\\left(d^2\\right)=\\begin{cases} \\Gamma - d^2, \u0026\\text{if } d^2 T_M\\end{cases} \\]\n其中，\\(M\\)为\\(H\\)或者\\(F\\)。\\(T_M\\)为距离阈值，根据95%的\\(\\chi^2\\)测试设置。 \\(T_H=5.99\\)（两个自由度），\\(T_F=3.84\\)（1个自由度）。这里假设标准差为1个像素。\n\\(\\Gamma\\) is defined equal to \\(T_H\\) so that both models score equally for the same d in their inlier region, again to make the process homogeneous.\n\\[ R_H=\\frac{S_H}{S_H+S_F} \\]\nselect the homography if \\(R_H0.45\\), which adequately captures the planar and low parallax cases. Otherwise, we select the fundamental matrix.\n三角化\nhttps://blog.csdn.net/weixin_43795395/article/details/93769148\nhttps://www.cnblogs.com/yepeichu/p/10792899.html\n已知匹配的像素点，及两帧图像的变换关系，则：\n\\[ x = PX \\\\[2mm] x' = P'X \\]\n根据\\(x^\\wedge PX = 0\\)性质，可得到如下方程：\n\\[ AX = \\begin{bmatrix} xp^{3T}-p^{1T} \\\\ yp^{3T}-p^{2T} \\\\ x'p'^{3T}-p'^{1T} \\\\ y'p'^{3T}-p'^{2T} \\end{bmatrix} X = 0 \\]\n对矩阵\\(A\\)进行SVD分解，可知：\n\\[ J(y) = \\min \\|Ax\\| = \\min \\|UDV^Tx\\| = \\min \\|DV^Tx\\| \\]\n由于对角阵\\(D\\)是矩阵\\(A\\)的奇异值从大到小降序排列而成，因此\\(J(y)\\) 的最小值在\\(D\\)矩阵奇异值最小的地方取到。可知：\n\\[ V^Tx = y = [0, 0, 0, 1]^T \\\\[2mm] x = Vy \\]\n于是，\\(x\\)的解就变成了正交矩阵\\(V\\)的最后一列的列向量。\n多余的话——解方程\nhttp://eigen.tuxfamily.org/dox/group__LeastSquares.html\n对于方程：\n\\[ Mx = b \\]\n可以使用最小二乘解\\(x = (M^T M)^{-1} M^T b\\)，或者利用QR分解\\(x = R^{-1} Q^T b\\)。\n将b移到左边，并设最后一个参数为1，可转换成如下方程：\n\\[ Mx = 0 \\]\n可以通过SVD分解，解对应于\\(M\\)最小特征值对应的特征向量。关于\\(M\\)与\\(M^T M\\)的SVD分解的关系， 可以参考“矩阵”一篇的笔记。\nTracking TrackWithMotionModel\nSearchByProjection --\u0026gt; PoseOptimization\nSearchByProjection:\nGetFeaturesInArea --\u0026gt; DescriptorDistance\nTrackWithReferenceKeyFrame\nSearchByBow --\u0026gt; PoseOptimization\nSearchByBow:\nFeatureVector --\u0026gt; DescriptorDistance --\u0026gt; ComputeThreeMaxima\nRelocalization\nSearchByBow --\u0026gt; EPnP(RANSAC) --\u0026gt; PoseOptimization --\u0026gt; SearchByProjection --\u0026gt; PoseOptimization\nEPnP:\nhttps://zhuanlan.zhihu.com/p/59070440\n 3D点的齐次坐标被表示为4个控制点齐次坐标的线性组合，然后将其作为已知量拿到相机坐标系下使用。 结合上一步，将相机坐标系下的空间点坐标，转换成4个控制点在摄像机坐标系下的坐标的线性组合，并结合对应的像素点坐标，建立方程，从而解算出控制点在摄像机坐标系下的坐标。 最后根据4个控制点，将所有的3D点在摄像机坐标系下的坐标恢复出来。接着采用ICP方法，求解出R和t。  ICP:\n 计算两组点的质心位置，然后计算每个点的去质心坐标  \\[ q_i = p_i - p \\\\[2mm] q_i' = p_i' - p' \\]\n求取R  \\[ W = \\sum_{i=1}^n q_i q_i'^T = U \\Sigma V^T \\\\[2mm] R = UV^T \\]\n求取t  \\[ t = p - R p' \\]\n\n题外话———未知对应关系的ICP：\n 根据距离最小寻找对应点 根据对应点，计算R和t 对点云进行转换，计算误差 重新寻找对应点，不断迭代，直至误差小于某一个值  属于EM算法的一种，待求变量为\\( [R | t] \\)，隐变量为点的对应关系。先固定第一个变量，优化另一个；再固定另一个，优化第一个变量。通过多次优化后，两个变量都达到最优值。\nUpdateLocalMap\nSearchByProjection --\u0026gt; PoseOptimization\nLocalMapping ComputeBow --\u0026gt; SearchForTriangulation --\u0026gt; LocalBA\nSearchForTriangulation:\nFeatureVector --\u0026gt; DescriptorDistance --\u0026gt; CheckDistEpipolarLine --\u0026gt; ComputeThreeMaxima\n关于优化中的卡方分布外点剔除\nhttps://zhuanlan.zhihu.com/p/58556978\n高斯白噪声的平方服从卡方分布，有几个观测量就代表几个自由度。\nLoopClosing TF-IDF TF: Term Frequency, 指某个特征在单幅图像中出现的频率。\n\\[ TF_i = \\frac{n_i}{n} \\]\nIDF: Inverse Document Frequency, 指单词在字典中出现的频率越高，则分类图像时区分度越高。\n\\[ IDF_i = \\log \\frac{n}{n_i} \\]\nComputeSim3 SearchByBow --\u0026gt; sim3(RANSAC) --\u0026gt; SearchBySim3 --\u0026gt; OptimizeSim3 --\u0026gt; SearchByProjection\n当两个姿态比较接近时，sim3求解不出有效值。这也是闭环成功后，后续很长一段时间里，不再进行闭环的原因。\nsim3:\n\nLoopClosing OptimizeEssentialGraph --\u0026gt; RunGlobalBundleAdjustment\nOptimization 点与位姿优化\n\\[ \\xi^* = \\arg \\min_\\xi \\frac{1}{2} \\sum_{i=1}^n {\\| u_i - \\frac{1}{s} K \\exp(\\xi^\\wedge) P_i \\|}_2^2 \\\\[2mm] P' = TP = RP + t \\\\[2mm] \\begin{bmatrix} u \\\\ v \\end{bmatrix} = \\begin{bmatrix}f_x \u00260 \u0026c_x \\\\ 0 \u0026f_y \u0026c_y\\end{bmatrix} \\begin{bmatrix}\\frac{X'}{Z'} \\\\ \\frac{Y'}{Z'}\\end{bmatrix} \\]\n回环（采用左扰动）\n实际ORB-SLAM的Pose Graph是采用的Sim3变换。此处仅推导SE(3)上的公式。\n\\[ \\begin{aligned} e_{ij} \u0026= \\ln (T_{ij}^{-1} T_i^{-1} T_j)^\\vee \\\\[2mm] \u0026= \\ln (T_{ij}^{-1} T_i^{-1} \\exp((-\\xi_i)^\\wedge) T_j)^\\vee \\\\[2mm] \u0026= \\ln (T_{ij}^{-1} T_i^{-1} T_j \\exp((-Ad(T_j^{-1})\\delta\\xi_i)^\\wedge))^\\vee \\\\[2mm] \u0026= \\ln (\\exp(e_{ij}^\\wedge) \\exp((-Ad(T_j^{-1})\\delta\\xi_i)^\\wedge))^\\vee \\\\[2mm] \u0026= \\mathcal{J}_r^{-1}(e_{ij}) (-Ad(T_j^{-1})\\delta\\xi_i) + e_{ij} \\\\[2mm] \\frac{ \\partial{e_{ij}} }{ \\partial{\\delta\\xi_i} } \u0026= -\\mathcal{J}_r^{-1}(e_{ij}) Ad(T_j^{-1}) \\end{aligned} \\]\n同理可得：\n\\[ \\frac{ \\partial{e_{ij}} }{ \\partial{\\delta\\xi_j} } = \\mathcal{J}_r^{-1}(e_{ij}) Ad(T_j^{-1}) \\]\n有以下近似关系：\n\\[ \\mathcal{J}_r^{-1}(e_{ij}) \\approx I + \\frac{1}{2} \\begin{bmatrix} \\phi_e^\\wedge \u0026\\rho_e^\\wedge \\\\ 0 \u0026\\phi_e^\\wedge \\end{bmatrix} \\]\nBowVector \u0026amp; FeatureVector    BowVector存储着叶子节点，信息最细微，仅用在DetectRelocalizationCandidates()函数中，用来选取备选帧。\nFeatureVector存储着倒数第4层的节点，信息比较粗糙，用在各种SearchBy*函数中，用来加速特征点的匹配。\nFeatureVector --\u0026gt; FClass 计算特征向量之间的距离，用于加速特征点匹配\nBowVector --\u0026gt; ScoringObject 计算单词之间的分数，用于匹配回环关键帧\nHKmeasStep --\u0026gt; createWords --\u0026gt; setNodeWeights\n先使用Kmeans++分为分层node；再将最后一层编码为word；最后每张图片对某个word计数最多加一次，计算权值\ng2o 采用se3表达参数；\n首先进行块分解，BlockSolver默认使用舒尔补消除变量;\n之后进行线性求解。其中LinearSolverDense直接进行Cholesky分解，LinearSolverEigen需要调用Eigen的稀疏Cholesky分解，且默认不reordering。因为在Schur之后，矩阵比较稠密，reordering影响不大；\nVeterx: oplusImpl\nEdge: ComputeError \u0026amp; linearizeOplus\nhttps://zhuanlan.zhihu.com/p/100522179\n","PublishDate":"2020-01-04T08:00:00+08:00","ReadingTime":3,"RelPermalink":"/orb-slam2/","Section":"blog","Stat":{"IsDir":false,"ModTime":"2020-01-27T19:57:10.03386962+08:00","Mode":436,"Name":"index.md","Size":9590},"Tags":null,"Title":"ORB-SLAM2","Type":"blog","Weight":0,"WordCount":559},{"Aliases":null,"File":{"BaseFileName":"index","ContentBaseName":"msckf","Dir":"blog/slam/msckf/","Ext":"md","Lang":"en","LogicalName":"index.md","Path":"blog/slam/msckf/index.md","TranslationBaseName":"index","UniqueID":"20bee235d2984684431c97569aafb493"},"FuzzyWordCount":700,"GitInfo":{"hash":"7e7a2000c988b2460dc5b2136847965e9905fdd8","abbreviatedHash":"7e7a200","subject":"1. add matrix page 2. add factor-graph page","authorName":"nuhuo08","authorEmail":"845776955@qq.com","authorDate":"2020-01-28T00:53:30+08:00","commitDate":"2020-01-28T00:53:30+08:00"},"Kind":"page","Lastmod":"2020-01-28T00:53:30+08:00","Len":6997,"Name":"MSCKF","Permalink":"https://nuhuo08.github.io/msckf/","Plain":"QR分解 \\[ A_{2m \\times 3} = Q_{2m \\times 2m}R_{2m \\times 3} = \\begin{bmatrix} B_{2m \\times 3} \u0026C_{2m \\times (2m - 3)} \\end{bmatrix} \\begin{bmatrix} D_{3 \\times 3} \\\\ 0_{(2m - 3) \\times 3} \\end{bmatrix} \\]\n其中，\\(Q\\) 为正交矩阵，每一列代表一个基向量，与除了自身以外的其他基向量的点积都为0。Where \\(B\\) and \\(C\\) are unitary matrices whose columns form bases for the range and nullspace of \\(A\\).\n\\[ {C^T}_{(2m-3) * 2m} A_{2m \\times 3} = \\begin{bmatrix} 0_{(2m-3) \\times 3} \u0026I_{(2m-3) \\times (2m - 3)} \\end{bmatrix} \\begin{bmatrix} D_{3 \\times 3} \\\\ 0_{(2m - 3) \\times 3} \\end{bmatrix} = 0_{(2m-3) \\times 3} \\]\n\\(C\\)称为\\(A\\)的左零空间，当左乘\\(C^T\\)以后，整个矩阵都变为0。\n\\[ {B^T}_{3 * 2m} A_{2m \\times 3} = \\begin{bmatrix} I_{3 \\times 3} \u00260_{3 \\times (2m - 3)} \\end{bmatrix} \\begin{bmatrix} D_{3 \\times 3} \\\\ 0_{(2m - 3) \\times 3} \\end{bmatrix} = D_{3 \\times 3} \\]\n当左乘\\(B^T\\)以后，仅重要信息被保留下来为\\(D\\)\n状态量 当前IMU状态\\(15\\)维，加上滑窗内\\(N\\)帧图像，每个相机位姿6维，共计\\(15+6N\\)\n\\[ {\\hat{X}}_k = \\begin{bmatrix} ^I_G\\bar{q} \\\\ {b_g} \\\\ {^Gv_I} \\\\ {b_a} \\\\ {^Gp_I} \\\\ {^{C_1}_G\\hat{\\bar{q}}} \\\\ ^G\\hat{p}_{C_1} \\\\ \\vdots \\\\ {^{C_N}_G\\hat{\\bar{q}}} \\\\ ^G\\hat{p}_{C_N} \\end{bmatrix} \\]\n状态增广 当增加第\\(N+1\\)个新的相机位姿时，状态向量需要增广。\n\\[ \\begin{bmatrix} ^I_G\\bar{q}^T \\\\ {b_g}^T \\\\ {^Gv_I}^T \\\\ {b_a}^T \\\\ {^Gp_I}^T \\\\ {^{C_1}_G\\hat{\\bar{q}}}^T \\\\ ^G\\hat{p}_{C_1}^T \\\\ \\vdots \\\\ {^{C_N}_G\\hat{\\bar{q}}}^T \\\\ ^G\\hat{p}_{C_N}^T \\\\ {^{C_{N+1}}_G\\hat{\\bar{q}}}^T \\\\ ^G\\hat{p}_{C_{N+1}}^T \\end{bmatrix} = \\underbrace{\\begin{bmatrix} I \u00260 \u00260 \u00260 \u00260 \u00260 \u00260 \u0026\\cdots \u00260 \u00260\\\\ 0 \u0026I \u00260 \u00260 \u00260 \u00260 \u00260 \u0026\\cdots \u00260 \u00260\\\\ 0 \u00260 \u0026I \u00260 \u00260 \u00260 \u00260 \u0026\\cdots \u00260 \u00260\\\\ 0 \u00260 \u00260 \u0026I \u00260 \u00260 \u00260 \u0026\\cdots \u00260 \u00260\\\\ 0 \u00260 \u00260 \u00260 \u0026I \u00260 \u00260 \u0026\\cdots \u00260 \u00260\\\\ 0 \u00260 \u00260 \u00260 \u00260 \u0026I \u00260 \u0026\\cdots \u00260 \u00260\\\\ 0 \u00260 \u00260 \u00260 \u00260 \u00260 \u0026I \u0026\\cdots \u00260 \u00260\\\\ \u0026 \u0026 \u0026 \u0026\\vdots \\\\ 0 \u00260 \u00260 \u00260 \u00260 \u00260 \u00260 \u0026\\cdots \u0026I \u00260\\\\ 0 \u00260 \u00260 \u00260 \u00260 \u00260 \u00260 \u0026\\cdots \u00260 \u0026I\\\\ C(^C_I\\bar{q}) \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026\\cdots \u00260 \u00260 \\\\ \\lfloor C_{\\hat{q}}^T p_C \\times \\rfloor \u00260 \u00260 \u0026 0 \u0026I \u00260 \u00260 \u0026\\cdots \u00260 \u00260 \\end{bmatrix}}_A * \\begin{bmatrix} ^I_G\\bar{q}^T \\\\ {b_g}^T \\\\ {^Gv_I}^T \\\\ {b_a}^T \\\\ {^Gp_I}^T \\\\ {^{C_1}_G\\hat{\\bar{q}}}^T \\\\ ^G\\hat{p}_{C_1}^T \\\\ \\vdots \\\\ {^{C_N}_G\\hat{\\bar{q}}}^T \\\\ ^G\\hat{p}_{C_N}^T \\end{bmatrix} \\]\n对应的协方差矩阵也需要进行传播。 \\( P_{k|k} = A P_{k|k} A^T \\)\n多余的话\n关于协方差增广，可以与 slam for dummies 进行对比学习。在该文中，新的特征点与当前的机器人位姿、激光观测量都有关系，其协方差为：\n\\[ P^{N+1 \\ N+1} = J_{xr} P J_{xr}^T + J_z R J_z^T \\]\n三角化点 将相机坐标当作已知值，优化共同观测到的某个特征点坐标\n\\[ h = \\begin{pmatrix} h_0 \\\\ h_1 \\\\ h_2 \\end{pmatrix} = R \\begin{pmatrix} \\frac{X}{Z} \\\\ \\frac{Y}{Z} \\\\ 1 \\end{pmatrix} + \\frac{1}{Z} t = R \\begin{pmatrix} \\alpha \\\\ \\beta \\\\ 1 \\end{pmatrix} + \\rho t \\\\ z = \\begin{pmatrix} \\frac{h_0}{h_2} \\\\ \\frac{h_1}{h_2} \\end{pmatrix} \\]\n由此得到雅可比矩阵：\n\\[ J = \\frac{\\partial e_i}{\\partial(\\alpha, \\beta, \\rho)} = -\\frac{\\partial z}{\\partial h} \\begin{bmatrix} \\frac{\\partial h}{\\partial \\alpha} \u0026 \\frac{\\partial h}{\\partial \\beta} \u0026 \\frac{\\partial h}{\\partial \\rho} \\end{bmatrix} \\\\ = -\\begin{bmatrix} \\frac{1}{h_2} \u0026 0 \u0026 -\\frac{h_0}{h_2^2} \\\\ 0 \u0026 \\frac{1}{h_2} \u0026 -\\frac{h_1}{h_2^2} \\end{bmatrix} \\begin{bmatrix} R\\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} \u0026 R\\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix} \u0026 t \\end{bmatrix} \\\\ \\]\n观测模型 特征点坐标是根据相机坐标计算出来的，而观测量误差同时与特征点和相机的坐标误差相关。\n\\[ ^{C_i} p_j = \\begin{bmatrix} ^{C_i} \\hat X_j \\\\ ^{C_i} \\hat Y_j \\\\ ^{C_i} \\hat Z_j \\end{bmatrix} =C(^{C_i} _G \\hat q)(^G \\hat p _{j} - ^G \\hat p _{C_i}) \\\\ \\hat z_i^{(j)} = \\begin{bmatrix} \\frac{^{C_i} \\hat X_j}{^{C_i} \\hat Z_j} \\\\ \\frac{^{C_i} \\hat Y_j}{^{C_i} \\hat Z_j} \\end{bmatrix} \\]\n对相机位姿、特征点位置的误差求雅可比：\n\\[ r_i^{(j)} \\approx \\frac{\\partial z_i^{(j)}}{\\partial ^{C_i} p_j} \\frac{\\partial ^{C_i} p_j}{\\partial X_{C_i}} \\tilde X + \\frac{\\partial z_i^{(j)}}{\\partial ^{C_i} p_j} \\frac{\\partial ^{C_i} p_j}{\\partial ^Gp_j} {^G}{\\tilde{p}_{j}} \\\\ = \\begin{bmatrix} \\frac{1}{^{C_i} \\hat Z_j} \u0026 0 \u0026 -\\frac{^{C_i} \\hat X_j}{^{C_i} \\hat Z_j} \\\\ 0 \u0026 \\frac{1}{^{C_i} \\hat Z_j} \u0026 -\\frac{^{C_i} \\hat Y_j}{^{C_i} \\hat Z_j} \\end{bmatrix} \\begin{bmatrix} \\lfloor {^{C_i} \\hat p _{j}}_\\times \\rfloor \u0026 -C(^{C_i} _G \\hat q) \\end{bmatrix} \\tilde X + \\begin{bmatrix} \\frac{1}{^{C_i} \\hat Z_j} \u0026 0 \u0026 -\\frac{^{C_i} \\hat X_j}{^{C_i} \\hat Z_j} \\\\ 0 \u0026 \\frac{1}{^{C_i} \\hat Z_j} \u0026 -\\frac{^{C_i} \\hat Y_j}{^{C_i} \\hat Z_j} \\end{bmatrix} \\begin{bmatrix} C(^{C_i} _G \\hat q) \\end{bmatrix} {^G}{\\tilde{p}_{j}} \\]\n精华：将观测到该特征点的多个相机观测值累积到一起形成大型矩阵，并将观测量误差投影到相机坐标误差雅可比矩阵的左零空间中，消去特征点坐标误差。由此，观测量误差仅与相机坐标误差相关！\n\\[ r^{(j)} \\simeq H_X^{(j)} \\tilde{X} + H_f^{(j)} {^G}{\\tilde{p}_{f_j}} + n^{(j)} \\\\ r_o^{(j)} = A^T r^{(j)} \\simeq A^T H_X^{(j)} \\tilde{X} + A^Tn^{(j)} = H_o^{(j)} \\tilde{X} ^{(j)} + n_o^{(j)} \\]\n滤波更新 使用QR分解，仅保留观测值中的有效信息。\n\\[ r_o = \\begin{bmatrix} Q_1 \u0026Q_2 \\end{bmatrix} \\begin{bmatrix} T_H \\\\ 0 \\end{bmatrix} \\tilde{X} + n_o \\\\ r_n = Q_1^Tr_o = T_H \\tilde{X} + n_n \\]\n滑窗的特殊性 MSCKF采用的是滤波方法，维护的是协方差，当要边缘化一个变量时，直接将其对应的行和列去掉即可！\n这与其他基于图优化的SLAM算法有显著区别。图优化SLAM需要维护H矩阵，即信息矩阵。信息矩阵的某一变量的边际概率，需要进行舒尔补操作！\n","PublishDate":"2020-01-03T08:00:00+08:00","ReadingTime":4,"RelPermalink":"/msckf/","Section":"blog","Stat":{"IsDir":false,"ModTime":"2020-01-28T00:08:22.09600158+08:00","Mode":436,"Name":"index.md","Size":6012},"Tags":null,"Title":"MSCKF","Type":"blog","Weight":0,"WordCount":672},{"Aliases":null,"File":{"BaseFileName":"index","ContentBaseName":"amcl","Dir":"blog/ros/amcl/","Ext":"md","Lang":"en","LogicalName":"index.md","Path":"blog/ros/amcl/index.md","TranslationBaseName":"index","UniqueID":"f453833cc0b7c5facd4816615a6d3ac6"},"FuzzyWordCount":200,"GitInfo":{"hash":"701154c262422f11f8f133c8717c04c31e75eab1","abbreviatedHash":"701154c","subject":"add navigation-stack page","authorName":"nuhuo08","authorEmail":"845776955@qq.com","authorDate":"2020-01-27T21:52:13+08:00","commitDate":"2020-01-27T21:52:13+08:00"},"Kind":"page","Lastmod":"2020-01-27T21:52:13+08:00","Len":6256,"Name":"AMCL","Permalink":"https://nuhuo08.github.io/amcl/","Plain":"ROS-AMCL    粒子聚类 对外输出的机器人状态不应该是某一个最好的粒子，因为很有可能某些粒子的值都非常接近，可能会引起频繁的粒子切换，导致输出的结果来回跳变。\n基于此考虑， 应该对相似的粒子进行聚类。将最好的那一簇粒子的统计状态作为输出的机器人状态。\nKD-Tree 当涉及到距离查找时，作为算法工程师，我们应该首先想到KD-Tree。树的叶子节点是每一个粒子，而非叶子节点则保存的是该节点的分叉判断的标准，小于此分叉判断标准的在左边，大于此分叉标准的在右边。\n查询的基本思路：首先通过二叉树搜索（比较待查询节点和分裂节点的分裂维的值，小于等于就进入左子树分支，等于就进入右子树分支直到叶子结点），顺着“搜索路径”很快能找到最近邻的近似点，也就是与待查询点处于同一个子空间的叶子结点；然后再回溯搜索路径，并判断搜索路径上的结点的其他子结点空间中是否可能有距离查询点更近的数据点，如果有可能，则需要跳到其他子结点空间中去搜索（将其他子结点加入到搜索路径）。重复这个过程直到搜索路径为空。\n   聚类 循环遍历每一个叶子节点，在叶子节点周围的 +-1 范围内的粒子都归为一类。例如在AMCL中，每个粒子周围27个粒子若有相连的，就将它们全部连成一片，形成一簇粒子。\n粒子滤波改进 为了防止机器人被绑架，出现粒子收敛于某一错误的地方，需要进行粒子滤波的改良。\n粒子注入 我们来考虑如下的式子：\n\\[ x_1 = x + 0.1(y-x) \\\\[2mm] x_2 = x + 0.9(y-x) \\]\n对于上面两个式子，展开以后我们可以发现：\\(x_1\\) 主要受到 \\(x\\) 的影响，而 \\(x_2\\) 主要受到 \\(y\\) 的影响。若粒子收敛于正确的状态，则 \\(y\\) 是准确的，\\(x_2\\) 将会比 \\(x_1\\) 更大，此时不需要注入粒子。若粒子收敛于错误的地方，则 \\(y\\) 不准确，此时 \\(x_1\\) 受到 \\(y\\) 的影响较小，\\(x_1\\) 更准确，此时便需要注入粒子。\n而这正是AMCL里面slow和fast参数产生的效果。\nKLD自适应 KLD的计算属于数理统计的知识，可参考论文1。这里进行直观的解释。\n例如，某一粒子权值很大。当我们进行100次采样，可能都采样到的是同一个粒子，此时粒子的个数始终保持为1。而KLD计算出来的需要采样的次数，是粒子个数的函数。因此，当粒子数保持为1时，KLD计算出来的次数为某一定值，而采样次数持续在增加，到某一时间点，便超过了需要的采样次数。\n而当粒子权值都接近时，假设我们采样了100次，每次采样出来的粒子都不同，此时粒子的个数一直增长到100。此时的KLD也随着粒子的个数增长到一个比较大的值。采样的次数虽然持续增加，但是始终超过不了KDL计算出来的次数。此种情况下采样仍将继续。\n距离计算 计算每个粒子的权重时，我们需要计算观测到的障碍物与地图中的障碍物的距离差异。差异越大，权值越小。当某次观测的障碍物全部与地图上的障碍物匹配上了，则差异为0，权值极大。因此，在地图的初始阶段，我们需要计算地图上任一点位置到最近障碍物的距离。这就是似然场模型。\n直接计算 遍历每一个点，计算每一个点到每个障碍物的距离并取最小值。此方法进行了重复计算，效率较低。\n高效算法 从障碍物出发，向外膨胀一个单位。当所有障碍物膨胀完以后，从膨胀出来的地方出发，继续向外膨胀一个单位。此方法没有冗余计算，且实现的代码简洁。\nAMCL参数解读 min_particles / max_particles / kld_err / kld_z : 用来限制粒子数量\nupdate_min_d / update_min_a / resample_interval : 限制冲采样条件\nrecovery_alpha_slow / recovery_alpha_fast : 动态调整粒子数量\ninitial_pose_xya / initial_cov_xxyyaa : 初始位置及其协方差\nodom_alpha1234 : 里程计运动模型误差系数\n参考资料 http://www.robots.ox.ac.uk/~cvrg/hilary2005/adaptive.pdf\nhttps://blog.csdn.net/Mark_SLAM/article/details/81266527\nhttps://zhuanlan.zhihu.com/p/28137335\nhttps://zhuanlan.zhihu.com/p/59411695\nhttps://zhuanlan.zhihu.com/p/59663340\nhttps://zhuanlan.zhihu.com/p/61908381\nudacity robot\ngithub particle filter\n","PublishDate":"2020-01-02T08:00:00+08:00","ReadingTime":1,"RelPermalink":"/amcl/","Section":"blog","Stat":{"IsDir":false,"ModTime":"2020-01-27T10:02:15.823267176+08:00","Mode":436,"Name":"index.md","Size":4812},"Tags":null,"Title":"AMCL","Type":"blog","Weight":0,"WordCount":102},{"Aliases":null,"File":{"BaseFileName":"index","ContentBaseName":"hugo-website","Dir":"blog/tools/hugo-website/","Ext":"md","Lang":"en","LogicalName":"index.md","Path":"blog/tools/hugo-website/index.md","TranslationBaseName":"index","UniqueID":"27183decc678898fbd825d96c0f31f67"},"FuzzyWordCount":200,"GitInfo":{"hash":"701154c262422f11f8f133c8717c04c31e75eab1","abbreviatedHash":"701154c","subject":"add navigation-stack page","authorName":"nuhuo08","authorEmail":"845776955@qq.com","authorDate":"2020-01-27T21:52:13+08:00","commitDate":"2020-01-27T21:52:13+08:00"},"Kind":"page","Lastmod":"2020-01-27T21:52:13+08:00","Len":2772,"Name":"Hugo Website","Permalink":"https://nuhuo08.github.io/hugo-website/","Plain":"申请Github账号 Github私人博客仓库 新建Hugo_Blogs仓库，此仓库保存个人的markdown源文件等。可设置为private仓库。\nGithub Pages 新建username.github.io的仓库，此仓库保存Hugo生成出来的html文件等。https://username.github.io/即为最终的个人博客地址。必须设置为public仓库。\n安装Hugo Hugo Tutorial\nBinary Package\n新建私人博客文件夹 创建网站文件夹 新建网站文件夹，并用hugo生成基本网站文件\nmkdir MyWebsite \u0026amp;\u0026amp; cd MyWebsite hugo new site . 链接Github私人博客仓库 添加git源，保存私人的markdown源文件\ngit init git remote add origin https://github.com/username/Hugo_Blogs.git 添加并使用新的theme git submodule add https://github.com/nuhuo08/uswds-hugo-theme.git themes/uswds-hugo-theme git submodule update --remote --merge cp themes/uswds-hugo-theme/exampleSite/config.yaml . 编辑网页 链接Github Pages 为了能够使用git submodule，需要先在仓库里添加点文件，之后再把它删掉。\nmkdir public \u0026amp;\u0026amp; cd public \u0026amp;\u0026amp; touch abc git remote add origin https://github.com/username/username.github.io.git git add . git commit -m \u0026quot;abc\u0026quot; git push orign master cd .. \u0026amp;\u0026amp; rm -rf public 然后再添加submodule，继续进行下一步。\ncd MyWebsite git submodule add https://github.com/username/username.github.io.git public 创建第一个网页 mkdir content/blog vi content/blog/my-first-blog.md 生成并本机预览网页 hugo hugo server -D 将改动上传至2个Git仓库 发布网页 hugo # if using a theme, replace with `hugo -t \u0026lt;YOURTHEME\u0026gt;` cd MyWebsite/public git add . git commit git push origin master 保存私人博客源文件 cd MyWebsite git add . git commit git push origin master ","PublishDate":"2020-01-01T08:00:00+08:00","ReadingTime":1,"RelPermalink":"/hugo-website/","Section":"blog","Stat":{"IsDir":false,"ModTime":"2020-01-27T10:02:32.067216942+08:00","Mode":436,"Name":"index.md","Size":2051},"Tags":null,"Title":"Hugo Website","Type":"blog","Weight":0,"WordCount":135},{"Aliases":null,"File":{"BaseFileName":"index","ContentBaseName":"about","Dir":"about/","Ext":"md","Lang":"en","LogicalName":"index.md","Path":"about/index.md","TranslationBaseName":"index","UniqueID":"8576ec274c98b3831668a172fa632d80"},"FuzzyWordCount":100,"GitInfo":{"hash":"18e92a3feff54bd6afcfac3ff7e4ee50992f8c6d","abbreviatedHash":"18e92a3","subject":"add amcl page","authorName":"nuhuo08","authorEmail":"845776955@qq.com","authorDate":"2020-01-25T18:24:08+08:00","commitDate":"2020-01-25T18:24:08+08:00"},"Kind":"page","Lastmod":"2020-01-25T18:24:08+08:00","Len":850,"Name":"About","Permalink":"https://nuhuo08.github.io/about/","Plain":"转眼已2020年，自己马上也要30了。三十而立，却一直没有可见的成绩。见过很多优秀的人，对自己的无所作为愈加愤怒。\n昨天晚上重读中央文献出版社的《毛泽东传》，看到这样一句话：\n\r\r毛泽东第一次进入中国共产党的领导核心，这时他三十岁，刚好是“而立”之年。\r\r慢慢的开始接受自己的平凡。不过，虽身不能至，然心向往之。从今天开始整理自己的私人网站，总结以前学过的各种知识， 记录自己的生活点滴与感悟，权当作一点点慰藉吧。\n\r\rTo learn, read; To know, write; To master, teach.\r\r做一点事，发一点光，写一点博客，找一点意义。\n","PublishDate":"2020-01-01T00:00:00Z","ReadingTime":1,"RelPermalink":"/about/","Section":"","Stat":{"IsDir":false,"ModTime":"2020-01-25T18:17:10.045246994+08:00","Mode":436,"Name":"index.md","Size":855},"Tags":null,"Title":"About","Type":"page","Weight":0,"WordCount":15}],"site":{"BaseURL":"https://nuhuo08.github.io","IsMultiLingual":false,"IsServer":false,"Language":{"Lang":"en","LanguageName":"","Title":"","Weight":0,"Disabled":false,"ContentDir":"","Cfg":{}},"LastChange":"2020-01-28T00:53:30+08:00","RSSLink":"https://nuhuo08.github.io/index.xml","Title":"XiaoWu"}}
