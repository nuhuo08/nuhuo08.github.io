{"hugo":{"BuildDate":"2020-01-05T18:57:23Z","CommitHash":"83e50184","Environment":"production","Version":"0.62.2"},"pages":[{"Aliases":null,"File":{"BaseFileName":"index","ContentBaseName":"gmapping","Dir":"blog/gmapping/","Ext":"md","Lang":"en","LogicalName":"index.md","Path":"blog/gmapping/index.md","TranslationBaseName":"index","UniqueID":"7a1883346c4142424b654d7ba05ccada"},"FuzzyWordCount":200,"GitInfo":null,"Kind":"page","Lastmod":"2020-01-08T08:00:00+08:00","Len":7915,"Name":"GMapping","Permalink":"https://nuhuo08.github.io/gmapping/","Plain":"基本理论 SLAM问题的分解 \\[ \\begin{aligned} p(x_{1:t},m|u_{1:t},z_{1:t}) \u0026= p(x_{1:t}|u_{1:t},z_{1:t}) p(m|u_{1:t},z_{1:t})\\\\ \u0026= p(x_{1:t}|u_{1:t},z_{1:t}) p(m|z_{1:t}) \\end{aligned} \\]\n将SLAM问题分解为：机器人的定位；基于已知机器人位姿的构图。\nFast-SLAM 根据贝叶斯公式，可以将机器人位姿的估计，转换成一个增量估计问题。\n\\[ \\begin{aligned} p(x_{1:t}|u_{1:t},z_{1:t}) \u0026= \\eta p(z_t|x_{1:t},u_{1:t},z_{1:t-1}) p(x_{1:t}|z_{1:t-1},u_{1,t})\\\\ \u0026= \\eta p(z_t|x_t) p(x_{1:t}|z_{1:t-1},u_{1:t})\\\\ \u0026= \\eta p(z_t|x_t) p(x_t|x_{1:t-1},z_{1:t-1},u_{1:t}) p(x_{1:t-1}|z_{1:t-1},u_{1:t})\\\\ \u0026= \\eta p(z_t|x_t) p(x_t|x_{t-1},u_{1:t}) p(x_{1:t-1}|z_{1:t-1},u_{1:t-1}) \\end{aligned} \\]\n其中，\\(p(x_{1:t-1}|z_{1:t-1},u_{1:t-1})\\)通过粒子群来表示； \\(p(x_t|x_{t-1},u_{1:t})\\)对每个粒子进行运动学模型的传播； \\(p(z_t|x_t)\\)根据观测模型计算权重。\n数据结构相关 Map template \u0026lt;class Cell, const bool debug=false\u0026gt; class Array2D{}; template \u0026lt;class Cell\u0026gt; class HierarchicalArray2D: public Array2D\u0026lt;autoptr\u0026lt; Array2D\u0026lt;Cell\u0026gt; \u0026gt; \u0026gt;{}; template \u0026lt;class Cell, class Storage, const bool isClass=true\u0026gt; class Map{}; typedef Map\u0026lt;PointAccumulator,HierarchicalArray2D\u0026lt;PointAccumulator\u0026gt; \u0026gt; ScanMatcherMap;  Array2D是一个二维数组，HierarchicalArray2D是一个Array2D的二维数组。 相当于将地图先分割成分辨率比较低的网格，只有当粒子运动到该网格时，才真正分配这个网格的内存。 网格的内存对应着分辨率高的真实的地图，用PointAccumulator来进行计数，记录激光是否通过该点，从而判断改点的状态：占据、空闲、未知。\nautoptr GMapping中自己实现了autoptr类，实现了智能指针的功能。\n运动更新 根据上一时刻的状态，结合里程计的输入量，可以得到当前时刻预估的状态。\n\\[ x_t = g_t(u_t, x_{t-1}) + \\varepsilon_t \\]\n权重计算 光束模型      使用Bresenham画线算法，进行高效的计算。 由于计算量过大、在非结构化环境中得分会突变，因此实际工程项目中很少采用此方法。\n\\[ p(z_t^k|x_t,m)=\\begin{pmatrix} z_{hit} \\\\ z_{short} \\\\ z_{max} \\\\ z_{rand} \\end{pmatrix}^T \\begin{pmatrix} p_{hit}(z_t^k|x_t,m) \\\\ p_{short}(z_t^k|x_t,m) \\\\ p_{max}(z_t^k|x_t,m) \\\\ p_{rand}(z_t^k|x_t,m) \\end{pmatrix} \\]\n似然场模型      对图像进行高斯平滑，不会出现得分突变的情况，且运算效率高，查表即可得到。是工程项目中常用的方法。\n重采样优化 里程计扩散出来的最好的粒子 若里程计信号质量误差较大，则需要大量粒子对验后分布进行模拟。由于每个粒子都携带一个地图，这将会造成巨大的内存消耗。 根据里程计的运动模型，每个粒子会扩散出很多粒子。从其中找出最好的那个粒子，其他的全去除，可以大量减少粒子数量。\n\\[ x_t^i \\sim p(x_t|u_t,x_{t-1}^i) \\\\[2mm] \\to x_t^i = \\arg \\max_{x_t}(p(z_t|x_t,m)p(x_t|u_t,x_{t-1}^i)) \\]\n抑制重采样次数 当采样次数过多时，会出现粒子耗散问题，即所有的粒子来自于少数几个粒子。\n\\[ N_{eff} = \\frac{1}{\\sum_{i = 1}^N \\left(\\tilde{w}^{(i)} \\right)^2} \\]\n当\\(N_{eff}\\)较大时，说明各粒子的差异性较小，此时不要进行重采样。反之，则应进行重采样。\n根据激光匹配估计出分布 由于激光的精度较高，可以通过激光的匹配，估计出一个高斯分布。并在此分布中进行采样，得到一系列粒子。\n建图算法 覆盖栅格建图 \\[ l(m_i|x_{1:t},z_{1:t})=l(m_i|x_t,z_t)+l(m_i|x_{1:t-1},z_{1:t-1})-l(m_i) \\]\n其中，\\(l(m_i|x_t,z_t)\\)表示会激光雷达的逆观测模型；\\(l(m_i|x_{1:t-1},z_{1:t-1})\\)表示栅格\\(m_i\\)在\\(t-1\\)时刻的状态， \\(l(m_i)\\)表示栅格\\(m_i\\)的先验值，对所有栅格都相同。\n计数建图法 \\[ m_j = \\frac{a_j}{a_j+b_j} \\]\n其中，\\(a_j\\)表示击中的次数，\\(b_j\\)表示未击中的次数。\n","PublishDate":"2020-01-08T08:00:00+08:00","ReadingTime":1,"RelPermalink":"/gmapping/","Section":"blog","Stat":{"IsDir":false,"ModTime":"2020-01-27T17:44:12.08219311+08:00","Mode":436,"Name":"index.md","Size":4343},"Tags":null,"Title":"GMapping","Type":"blog","Weight":0,"WordCount":160},{"Aliases":null,"File":{"BaseFileName":"index","ContentBaseName":"slam-for-dummies","Dir":"blog/slam-for-dummies/","Ext":"md","Lang":"en","LogicalName":"index.md","Path":"blog/slam-for-dummies/index.md","TranslationBaseName":"index","UniqueID":"1b1ffd23758bf4831de2d3a80d4b5e34"},"FuzzyWordCount":300,"GitInfo":{"hash":"e4d6dad6087ba976ce58db1543273945c4eb2785","abbreviatedHash":"e4d6dad","subject":"1. add slam-for-dummies page 2. add DBoW2 and AMCL pic","authorName":"nuhuo08","authorEmail":"845776955@qq.com","authorDate":"2020-01-26T15:20:07+08:00","commitDate":"2020-01-26T15:20:07+08:00"},"Kind":"page","Lastmod":"2020-01-26T15:20:07+08:00","Len":1949,"Name":"SLAM for Dummies","Permalink":"https://nuhuo08.github.io/slam-for-dummies/","Plain":"TO BE CONTINUED\nhttps://zhuanlan.zhihu.com/p/32937247\n观测方程 \\[ \\underbrace{\\begin{pmatrix} r_1 \\\\ \\theta_1 \\\\ r_2 \\\\ \\theta_2 \\\\ \\vdots \\\\ r_n \\\\ \\theta_n \\end{pmatrix}}_Z = \\underbrace{\\begin{bmatrix} A_1 \u0026B_1 \u0026C_1 \u0026-A_1 \u0026-B_1 \\\\ D_1 \u0026E_1 \u0026F_1 \u0026-D_1 \u0026-E_1 \\\\ A_2 \u0026B_2 \u0026C_2 \u0026 \u0026 \u0026-A_2 \u0026-B_2 \\\\ D_2 \u0026E_2 \u0026F_2 \u0026 \u0026 \u0026-D_2 \u0026-E_2 \\\\ \u0026\\vdots \u0026 \u0026 \u0026 \u0026 \u0026 \u0026 \\ddots \\\\ A_n \u0026B_n \u0026C_n \u0026 \u0026 \u0026 \u0026 \u0026 \u0026-A_n \u0026-B_n \\\\ D_n \u0026E_n \u0026F_n \u0026 \u0026 \u0026 \u0026 \u0026 \u0026-D_n \u0026-E_n \\\\ \\end{bmatrix}}_H \\underbrace{\\begin{pmatrix} x_r \\\\ y_r \\\\ \\theta_r \\\\ x_1 \\\\ y_1 \\\\ x_2 \\\\ y_2 \\\\ \\vdots \\\\ x_n \\\\ y_n \\end{pmatrix}}_X \\\\[2mm] R = \\begin{pmatrix} r_c \u0026 \\\\ \u0026r_d \\end{pmatrix} \\]\n动态方程 \\[ \\underbrace{\\begin{pmatrix} x_r \\\\ y_r \\\\ \\theta_r \\end{pmatrix}}_{X_{k+1}} = \\underbrace{\\begin{bmatrix} 1 \u0026 \u0026-\\Delta y \\\\ \u00261 \u0026\\Delta x \\\\ \u0026 \u00261\\end{bmatrix}}_A \\underbrace{\\begin{pmatrix} x_r \\\\ y_r \\\\ \\theta_r \\end{pmatrix}}_{X_k} \\\\[2mm] Q = \\begin{pmatrix} c\\Delta x^2 \\\\ \u0026 c\\Delta y^2 \\\\ \u0026 \u0026c\\Delta t^2\\end{pmatrix} \\]\n新增路标点的协方差矩阵增广 landmark wrt. robot state \\[ J_{xr} = \\begin{bmatrix} 1 \u0026 \u0026-\\Delta y \\\\ \u00261 \u0026\\Delta x\\end{bmatrix} \\]\nlandmark wrt. [range, bearing] \\[ J_z = \\begin{bmatrix} \\cos(\\theta + \\Delta \\theta) \u0026-\\Delta t \\cdot \\sin(\\theta + \\Delta \\theta) \\\\ \\sin(\\theta + \\Delta \\theta) \u0026\\Delta t \\cdot \\cos(\\theta + \\Delta \\theta) \\end{bmatrix} \\]\ncovariance \\[ P^{r \\ {N+1}} = P^{rr}J_{xr}^T \\\\[2mm] P^{i \\ {N+1}} = P^{ri}J_{xr}^T \\\\[2mm] P^{{N+1} \\ {N+1}} = J_{xr}PJ_{xr}^T + J_zRJ_z^T \\]\n","PublishDate":"2020-01-07T08:00:00+08:00","ReadingTime":2,"RelPermalink":"/slam-for-dummies/","Section":"blog","Stat":{"IsDir":false,"ModTime":"2020-01-26T13:29:24.332568402+08:00","Mode":436,"Name":"index.md","Size":1615},"Tags":null,"Title":"SLAM for Dummies","Type":"blog","Weight":0,"WordCount":231},{"Aliases":null,"File":{"BaseFileName":"index","ContentBaseName":"non-linear","Dir":"blog/non-linear/","Ext":"md","Lang":"en","LogicalName":"index.md","Path":"blog/non-linear/index.md","TranslationBaseName":"index","UniqueID":"c85e47a4aaf6174c6ee628e3e368b75c"},"FuzzyWordCount":300,"GitInfo":{"hash":"24c9e8cdacbcefe97a42ae8f8c54457b2fa827c6","abbreviatedHash":"24c9e8c","subject":"1. add vins-mono page 2. add non-linear part 1: ceres for vins-mono 3. modify deploy script","authorName":"nuhuo08","authorEmail":"845776955@qq.com","authorDate":"2020-01-26T11:47:06+08:00","commitDate":"2020-01-26T11:47:06+08:00"},"Kind":"page","Lastmod":"2020-01-26T11:47:06+08:00","Len":4657,"Name":"Non-Linear","Permalink":"https://nuhuo08.github.io/non-linear/","Plain":"g2o g2o在ORB-SLAM2中的用法 Ceres http://ceres-solver.org/nnls_modeling.html\n对于以下代价函数：\n\\[ \\frac{1}{2} \\sum_i \\rho_i(\\parallel f_i(x_{i1}, x_{i2}, \\cdots, x_{ik}) \\parallel ^2) \\]\n在Ceres中，\\(\\rho\\)为loss function，用于减弱外点的影响；\\(f\\)为cost function，定义了残差的计算方式；\\((x_{i1}, x_{i2}, \\cdots, x_{ik})\\)为parameter block，定义了需要估计的变量；\\(\\rho_i(\\parallel f_i(x_{i1}, x_{i2}, \\cdots, x_{ik}) \\parallel ^2)\\)为residual block，定义了一个残差块。\nAddResidualBlock problem.AddResidualBlock(costfunction, lossfunction, x1, x2 ... xn)\n其中，\\(x_1, x_2, \\cdots x_n\\)要与costfunction中的变量维数要对应起来。\ncostfunction有两种典型的定义方式：\n 自己实现残差、雅可比  templateclass SizedCostFunction : public CostFunction { public: virtual bool Evaluate(double const* const* parameters, double* residuals, double** jacobians) const = 0; }; 这种情况下，需要指定残差维数、参数块维数，并自己实现Evaluate()，计算cost和jacobian。\n自己实现残差即可  template class AutoDiffCostFunction : public SizedCostFunction{ public: explicit AutoDiffCostFunction(CostFunctor* functor); // Ignore the template parameter kNumResiduals and use // num_residuals instead. AutoDiffCostFunction(CostFunctor* functor, int num_residuals); }; 这种情况下，不再需要自己计算jacobian。只需要定义CostFunctor，计算残差，实现operator()函数。例如：\nclass MyScalarCostFunctor { MyScalarCostFunctor(double k): k_(k) {} template bool operator()(const T* const x , const T* const y, T* e) const { e[0] = k_ - x[0] * y[0] - x[1] * y[1]; return true; } private: double k_; }; AddParameterBlock ceres::LocalParameterization *local_parameterization = new PoseLocalParameterization(); problem.AddParameterBlock(para_Pose[i], SIZE_POSE, local_parameterization); problem.AddParameterBlock(para_SpeedBias[i], SIZE_SPEEDBIAS); Sometimes the parameters \\(x\\) can overparameterize a problem. In that case it is desirable to choose a parameterization to remove the null directions of the cost.\nCeres在VINS中的用法 Factor VINS 中用 IMUFactor 表示 IMU 的 cost function，用 ProjectionFactor 表示图像重投影误差的 cost function。其中定义了对各个参数块的残差、雅可比。\nMarginalizationFactor 表达了先验残差的更新方式。在Evaluate()函数中，实现了如下更新： \nResidualBlockInfo 为了进行 Schur，在 cost function 外面包了一层 ResidualBlockInfo。因为在原生Ceres中，一旦调用 problem.AddResidualBlock(costfunction, lossfunction, x1, x2 ... xn)，便不再能干预内部处理流程。\n在这个自定义的 ResidualBlockInfo 的 Evaluate() 中，调用了每个 cost function 原生的 Evaluate()，获得残差、雅可比，然后将 loss function 的功能也在此调用，组装好以后，留给 MarginalizationInfo 做进一步处理。\nMarginalizationInfo addResidualBlockInfo() 处理优化变量、待边缘化变量\npreMarginalize()\nmarginalize() 并行化线程，进行舒尔补计算\n","PublishDate":"2020-01-06T08:00:00+08:00","ReadingTime":2,"RelPermalink":"/non-linear/","Section":"blog","Stat":{"IsDir":false,"ModTime":"2020-01-26T11:16:31.472390926+08:00","Mode":436,"Name":"index.md","Size":3899},"Tags":null,"Title":"Non-Linear","Type":"blog","Weight":0,"WordCount":219},{"Aliases":null,"File":{"BaseFileName":"index","ContentBaseName":"vins-mono","Dir":"blog/vins-mono/","Ext":"md","Lang":"en","LogicalName":"index.md","Path":"blog/vins-mono/index.md","TranslationBaseName":"index","UniqueID":"42586f11c6657592a788c0efdff57450"},"FuzzyWordCount":500,"GitInfo":{"hash":"24c9e8cdacbcefe97a42ae8f8c54457b2fa827c6","abbreviatedHash":"24c9e8c","subject":"1. add vins-mono page 2. add non-linear part 1: ceres for vins-mono 3. modify deploy script","authorName":"nuhuo08","authorEmail":"845776955@qq.com","authorDate":"2020-01-26T11:47:06+08:00","commitDate":"2020-01-26T11:47:06+08:00"},"Kind":"page","Lastmod":"2020-01-26T11:47:06+08:00","Len":10340,"Name":"VINS-MONO","Permalink":"https://nuhuo08.github.io/vins-mono/","Plain":"代码流程图      动态方程 预积分公式推导 \\(b_k^a\\)和\\(b_k^g\\)作为随机游走噪声，在推导\\(k \\sim k+1\\)时认为是常数！不像\\(w\\)和\\(a\\)，要添加\\(n_k^g\\)和\\(n_k^a\\)噪声进去\n\\[ \\omega=\\frac{1}{2}( (\\omega^{b_k}+n_k^g-b_k^g) + (\\omega^{b_{k+1}}+n_{k+1}^g-b_k^g) ) \\\\[2mm] q_{b_ib_{k+1}}=q_{b_ib_k}\\otimes\\begin{bmatrix}1 \\\\ \\frac{1}{2}\\omega\\delta{t}\\end{bmatrix} \\\\[2mm] a=\\frac{1}{2}( q_{b_ib_k}(a^{b_k}+n_k^a-b_k^a) + q_{b_ib_{k+1}}(a^{b_{k+1}}+n_{k+1}^a-b_k^a) ) \\\\[2mm] \\beta_{b_ib_{k+1}}=\\beta_{b_ib_k}+a\\delta{t} \\\\[2mm] \\alpha_{b_ib_{k+1}}=\\alpha_{b_ib_k}+\\beta_{b_ib_k}\\delta{t}+\\frac{1}{2}a\\delta{t}^2 \\\\[2mm] b_{k+1}^a=b_k^a+n_{b_k^a}\\delta{t} \\\\[2mm] b_{k+1}^g=b_k^g+n_{b_k^g}\\delta{t} \\\\[2mm] \\]\n写成矩阵形式：\n\\[ \\begin{bmatrix}\\alpha_{b_ib_{k+1}} \\\\ \\theta_{b_ib_{k+1}} \\\\ \\beta_{b_ib_{k+1}} \\\\ b_{k+1}^a \\\\ b_{k+1}^g\\end{bmatrix} =F*\\begin{bmatrix}\\alpha_{b_ib_{k}} \\\\ \\theta_{b_ib_{k}} \\\\ \\beta_{b_ib_{k}} \\\\ b_{k}^a \\\\ b_{k}^g\\end{bmatrix} +G*\\begin{bmatrix}n_k^a \\\\ n_k^g \\\\ n_{k+1}^a \\\\ n_{k+1}^g \\\\ n_{k}^a \\\\ n_{k}^g \\end{bmatrix} \\]\n\\[ F=\\begin{bmatrix}I \u0026f_{12} \u0026I\\delta{t} \u0026-\\frac{1}{4}(q_{b_ib_k}+q_{b_ib_{k+1}})\\delta{t}^2 \u0026f_{15}\\\\ 0 \u0026I-[\\omega]_{\\times} \u00260 \u00260 \u0026-I\\delta{t}\\\\ 0 \u0026f_{32} \u0026I \u0026-\\frac{1}{2}(q_{b_ib_k}+q_{b_ib_{k+1}})\\delta{t} \u0026f_{35}\\\\ 0 \u00260 \u00260 \u0026I \u00260\\\\ 0 \u00260 \u00260 \u00260 \u0026I \\end{bmatrix} \\\\[2mm] G=\\begin{bmatrix}\\frac{1}{4}q_{b_ib_k}\\delta{t}^2 \u0026g_{12} \u0026\\frac{1}{4}q_{b_ib_{k+1}}\\delta{t}^2 \u0026g_{14} \u00260 \u00260 \\\\ 0 \u0026\\frac{1}{2}I\\delta{t} \u00260 \u0026\\frac{1}{2}I\\delta{t} \u00260 \u00260\\\\ \\frac{1}{2}q_{b_ib_k}\\delta{t} \u0026g_{32} \u0026\\frac{1}{2}q_{b_ib_{k+1}}\\delta{t} \u0026g_{34} \u00260 \u00260\\\\ 0 \u00260 \u00260 \u00260 \u0026I\\delta{t} \u00260\\\\ 0 \u00260 \u00260 \u00260 \u00260 \u0026I\\delta{t}\\end{bmatrix} \\\\[2mm] f_{12}=-\\frac{1}{4}( R_{b_ib_k}[a^{b_k}-b_k^a]_\\times\\delta{t}^2 + R_{b_ib_{k+1}}[a^{b_{k+1}}-b_k^a]_\\times(I-[\\omega]_\\times\\delta{t})\\delta{t}^2) \\\\[2mm] f_{32}=-\\frac{1}{2}( R_{b_ib_k}[a^{b_k}-b_k^a]_\\times\\delta{t} + R_{b_ib_{k+1}}[a^{b_{k+1}}-b_k^a]_\\times(I-[\\omega]_\\times\\delta{t})\\delta{t}) \\\\[2mm] f_{15}=-\\frac{1}{4}(R_{b_ib_{k+1}}[a^{b_{k+1}}-b_k^a]_\\times\\delta{t}^2)(-\\delta{t}) \\\\[2mm] f_{35}=-\\frac{1}{2}(R_{b_ib_{k+1}}[a^{b_{k+1}}-b_k^a]_\\times\\delta{t})(-\\delta{t}) \\\\[2mm] g_{12}=g_{14}=-\\frac{1}{4}(R_{b_ib_{k+1}}[a^{b_{k+1}}-b_k^a]_\\times\\delta{t}^2)(\\frac{1}{2}\\delta{t}) \\\\[2mm] g_{32}=g_{34}=-\\frac{1}{2}(R_{b_ib_{k+1}}[a^{b_{k+1}}-b_k^a]_\\times\\delta{t})(\\frac{1}{2}\\delta{t}) \\]\n终极大矩阵 将所有值带进去并展开，得到原始等式\n\\[ q_{b_ib_{k+1}}=q_{b_ib_k}\\otimes\\begin{bmatrix}1 \\\\ \\frac{1}{2}\\{\\frac{1}{2}( (\\omega^{b_k}+n_k^g-b_k^g) + (\\omega^{b_{k+1}}+n_{k+1}^g-b_k^g) )\\}\\delta{t}\\end{bmatrix} \\\\[2mm] \\beta_{b_ib_{k+1}}=\\beta_{b_ib_k}+\\{\\frac{1}{2}( q_{b_ib_k}(a^{b_k}+n_k^a-b_k^a) + \\{q_{b_ib_k}\\otimes\\begin{bmatrix}1 \\\\ \\frac{1}{2}\\{\\frac{1}{2}( (\\omega^{b_k}+n_k^g-b_k^g) + (\\omega^{b_{k+1}}+n_{k+1}^g-b_k^g) )\\}\\delta{t}\\end{bmatrix}\\}(a^{b_{k+1}}+n_{k+1}^a-b_k^a) )\\}\\delta{t} \\\\[2mm] \\alpha_{b_ib_{k+1}}=\\alpha_{b_ib_k}+\\beta_{b_ib_k}\\delta{t}+\\frac{1}{2}\\{\\frac{1}{2}( q_{b_ib_k}(a^{b_k}+n_k^a-b_k^a) + \\{q_{b_ib_k}\\otimes\\begin{bmatrix}1 \\\\ \\frac{1}{2}\\{\\frac{1}{2}( (\\omega^{b_k}+n_k^g-b_k^g) + (\\omega^{b_{k+1}}+n_{k+1}^g-b_k^g) )\\}\\delta{t}\\end{bmatrix}\\}(a^{b_{k+1}}+n_{k+1}^a-b_k^a) )\\}\\delta{t}^2 \\\\[2mm] b_{k+1}^a=b_k^a+n_{b_k^a}\\delta{t} \\\\[2mm] b_{k+1}^g=b_k^g+n_{b_k^g}\\delta{t} \\]\n矩阵形式\n\\[ \\begin{bmatrix}\\alpha_{b_ib_{k+1}} \\\\ \\theta_{b_ib_{k+1}} \\\\ \\beta_{b_ib_{k+1}} \\\\ b_{k+1}^a \\\\ b_{k+1}^g\\end{bmatrix} =\\begin{bmatrix}I \u0026-\\frac{1}{4}( R_{b_ib_k}[a^{b_k}-b_k^a]_\\times\\delta{t}^2 + R_{b_ib_{k+1}}[a^{b_{k+1}}-b_k^a]_\\times(I-[\\omega]_\\times\\delta{t})\\delta{t}^2) \u0026I\\delta{t} \u0026-\\frac{1}{4}(q_{b_ib_k}+q_{b_ib_{k+1}})\\delta{t}^2 \u0026-\\frac{1}{4}(R_{b_ib_{k+1}}[a^{b_{k+1}}-b_k^a]_\\times\\delta{t}^2)(-\\delta{t})\\\\ 0 \u0026I-[\\omega]_{\\times} \u00260 \u00260 \u0026-I\\delta{t}\\\\ 0 \u0026-\\frac{1}{2}( R_{b_ib_k}[a^{b_k}-b_k^a]_\\times\\delta{t} + R_{b_ib_{k+1}}[a^{b_{k+1}}-b_k^a]_\\times(I-[\\omega]_\\times\\delta{t})\\delta{t}) \u0026I \u0026-\\frac{1}{2}(q_{b_ib_k}+q_{b_ib_{k+1}})\\delta{t} \u0026-\\frac{1}{2}(R_{b_ib_{k+1}}[a^{b_{k+1}}-b_k^a]_\\times\\delta{t})(-\\delta{t})\\\\ 0 \u00260 \u00260 \u0026I \u00260\\\\ 0 \u00260 \u00260 \u00260 \u0026I \\end{bmatrix} *\\begin{bmatrix}\\alpha_{b_ib_{k}} \\\\ \\theta_{b_ib_{k}} \\\\ \\beta_{b_ib_{k}} \\\\ b_{k}^a \\\\ b_{k}^g\\end{bmatrix}\\\\ +\\begin{bmatrix}\\frac{1}{4}q_{b_ib_k}\\delta{t}^2 \u0026-\\frac{1}{4}(R_{b_ib_{k+1}}[a^{b_{k+1}}-b_k^a]_\\times\\delta{t}^2)(\\frac{1}{2}\\delta{t}) \u0026\\frac{1}{4}q_{b_ib_{k+1}}\\delta{t}^2 \u0026-\\frac{1}{4}(R_{b_ib_{k+1}}[a^{b_{k+1}}-b_k^a]_\\times\\delta{t}^2)(\\frac{1}{2}\\delta{t}) \u00260 \u00260 \\\\ 0 \u0026\\frac{1}{2}I\\delta{t} \u00260 \u0026\\frac{1}{2}I\\delta{t} \u00260 \u00260\\\\ \\frac{1}{2}q_{b_ib_k}\\delta{t} \u0026-\\frac{1}{2}(R_{b_ib_{k+1}}[a^{b_{k+1}}-b_k^a]_\\times\\delta{t})(\\frac{1}{2}\\delta{t}) \u0026\\frac{1}{2}q_{b_ib_{k+1}}\\delta{t} \u0026-\\frac{1}{2}(R_{b_ib_{k+1}}[a^{b_{k+1}}-b_k^a]_\\times\\delta{t})(\\frac{1}{2}\\delta{t}) \u00260 \u00260\\\\ 0 \u00260 \u00260 \u00260 \u0026I\\delta{t} \u00260\\\\ 0 \u00260 \u00260 \u00260 \u00260 \u0026I\\delta{t}\\end{bmatrix} *\\begin{bmatrix}n_k^a \\\\ n_k^g \\\\ n_{k+1}^a \\\\ n_{k+1}^g \\\\ n_{k}^a \\\\ n_{k}^g \\end{bmatrix} \\]\n观测方程 相机 观测方程：\n\\[ P_{w_l}=R_{b_i}^w(R_c^b\\frac{1}{\\lambda_l}\\pi_c^{-1}(\\begin{bmatrix}\\mu_l^{c_i}\\\\\\nu_l^{c_i}\\end{bmatrix})+p_c^b)+p_{b_i}^w \\\\[2mm] P_{w_l}=R_{b_j}^w(R_c^bP_l^{c_j}+p_c^b)+p_{b_j}^w \\\\[2mm] P_l^{c_j}=R_b^c\\{R_w^{b_j}[R_{b_i}^w(R_c^b\\frac{1}{\\lambda_l}\\overline{P}_l^{c_i}+p_c^b)+p_{b_i}^w-p_{b_j}^w]-p_c^b\\} \\]\n转换成矩阵形式：\n\\[ P_l^{c_j}=\\begin{bmatrix} R_b^cR_w^{b_j} \\\\ -R_b^cR_w^{b_j}R_{b_i}^w(R_c^b\\frac{1}{\\lambda_l}\\overline{P}_l^{c_i}+p_c^b)^{\\wedge} \\\\ -R_b^cR_w^{b_j} \\\\ R_b^c\\{R_w^{b_j}[R_{b_i}^w(R_c^b\\frac{1}{\\lambda_l}\\overline{P}_l^{c_i}+p_c^b)+p_{b_i}^w-p_{b_j}^w]\\}^\\wedge \\\\ R_b^c(R_w^{b_j}R_{b_i}^w-I_{3\\times3}) \\\\ -R_b^cR_w^{b_j}R_{b_i}^wR_c^b(\\frac{1}{\\lambda_l}\\overline{P}_l^{c_i})^{\\wedge}+(R_b^cR_w^{b_j}R_{b_i}^wR_c^b\\frac{1}{\\lambda_l}\\overline{P}_l^{c_i})^{\\wedge}+\\{R_b^c[R_w^{b_j}(R_{b_i}^wp_c^b+p_{b_i}^w-p_{b_j}^w)-p_c^b]\\}^{\\wedge} \\\\ -R_b^cR_w^{b_j}R_{b_i}^wR_c^b\\frac{1}{\\lambda_l^2}\\overline{P}_l^{c_i} \\end{bmatrix}^T *\\begin{bmatrix} p_{b_i}^w \\\\ q_{b_i}^w \\\\ p_{b_j}^w \\\\ q_{b_j}^w \\\\ p_c^b \\\\ q_c^b \\\\ \\lambda_l \\end{bmatrix} \\]\nIMU 观测方程：\n\\[ \\gamma_B=\\begin{bmatrix} R_w^{b_k}(p_{b_{k+1}}^w-p_{b_k}^w-\\nu_{b_k}^w\\Delta{t_k}+\\frac{1}{2}g^w\\Delta{t_k^2})-\\alpha_{b_{k+1}}^{b_k} \\\\ 2[\\gamma_{b_{k+1}}^{b_k}{\\otimes}{q_{b_k}^w}^{-1}\\otimes{q_{b_{k+1}}^w}] \\\\ R_w^{b_k}(\\nu_{b_{k+1}}^w-\\nu_{b_k}^w+g^w\\Delta{t_k})-\\beta_{b_{k+1}}^{b_k} \\\\ b_{a_{b_{k+1}}}-b_{a_{b_k}} \\\\ b_{\\omega_{b_{k+1}}}-b_{\\omega_{b_k}} \\end{bmatrix} \\]\n转换成矩阵形式：\n\\[ \\gamma_B=\\begin{bmatrix} -R_w^{b_k} \u00260 \u00260 \u00260 \u00260 \\\\ [R_w^{b_k}(p_{b_{k+1}}^w-p_{b_k}^w-\\nu_{b_k}^w\\Delta{t_k}+\\frac{1}{2}g^w\\Delta{t_k^2})]^\\wedge \u0026-\\mathcal{L}[{q_{b_{k+1}}^w}^{-1}\\otimes{q_{b_k}^w}]\\mathcal{R}[\\gamma_{b_{k+1}}^{b_k}] \u0026[R_w^{b_k}(\\nu_{b_{k+1}}^w-\\nu_{b_k}^w+g^w\\Delta{t_k})]^\\wedge \u00260 \u00260\\\\ -R_w^{b_k}\\Delta{t} \u00260 \u0026-R_w^{b_k} \u00260 \u00260\\\\ -\\mathcal{J}_{b_a}^\\alpha \u00260 \u0026-\\mathcal{J}_{b_a}^\\beta \u0026-I \u00260 \\\\ -\\mathcal{J}_{b_\\omega}^\\alpha \u0026-\\mathcal{L}[{q_{b_{k+1}}^w}^{-1}\\otimes{q_{b_k}^w}\\otimes\\gamma_{b_{k+1}}^{b_k}]\\mathcal{J}_{b_\\omega}^\\gamma \u0026-\\mathcal{J}_{b_\\omega}^\\beta \u00260 \u0026-I \\\\ R_w^{b_k} \u00260 \u00260 \u00260 \u00260 \\\\ 0 \u0026\\mathcal{L}[{\\gamma_{b_{k+1}}^{b_k}}^{-1}\\otimes{q_{b_{k}}^w}^{-1}\\otimes{q_{b_{k+1}}^w}] \u00260 \u00260 \u00260\\\\ 0 \u00260 \u0026R_w^{b_k} \u00260 \u00260\\\\ 0 \u00260 \u00260 \u0026I \u00260\\\\ 0 \u00260 \u00260 \u00260 \u0026I \\end{bmatrix}^T *\\begin{bmatrix} p_{b_k}^w \\\\ q_{b_k}^w \\\\ v_{b_k}^w \\\\ b_{a_k} \\\\ b_{\\omega_k} \\\\ p_{b_{k+1}}^w \\\\ q_{b_{k+1}}^w \\\\ v_{b_{k+1}}^w \\\\ b_{a_{k+1}} \\\\ b_{\\omega_{k+1}} \\end{bmatrix} \\]\n在线标定 求解 使方程满秩可求解 信息矩阵 \\(H\\) 不满秩\n 用LM方法求解，会导致H满秩 --\u0026gt; 解在空间中整体变化 添加先验约束，增加系统可观性。例如固定第一个相机，\\(H_{[11]}+=I\\) 添加超强先验，使得对应的信息矩阵巨大\\(H_{[11]}=\\infty\\)，就能使得\\(\\Delta{x}=H^{-1}b=0\\) 设定对应雅克比矩阵为 0，则\\(H_{[11]}=0\\)，\\(b_{[1]}=0\\)。则在求解时，\\((0+\\lambda{I})\\Delta{x}=0\\)  舒尔补      更新先验残差 \\[ b_p^{'}=b_p+\\frac{\\partial{b_p}}{\\partial{x_p}}\\delta{x_p}\\\\ =b_p+\\frac{\\partial{(-J^T\\Sigma^{-1}r)}}{\\partial{x_p}}\\delta{x_p}\\\\ =b_p-\\Lambda_p\\delta{x_p} \\]\nCeres在VINS-MONO中的使用 Ceres的具体用法，及其在VINS-MONO中的用法，请参考如下文章： non-linear\n","PublishDate":"2020-01-05T08:00:00+08:00","ReadingTime":3,"RelPermalink":"/vins-mono/","Section":"blog","Stat":{"IsDir":false,"ModTime":"2020-01-26T11:22:35.56548329+08:00","Mode":436,"Name":"index.md","Size":8740},"Tags":null,"Title":"VINS-MONO","Type":"blog","Weight":0,"WordCount":439},{"Aliases":null,"File":{"BaseFileName":"index","ContentBaseName":"orb-slam2","Dir":"blog/orb-slam2/","Ext":"md","Lang":"en","LogicalName":"index.md","Path":"blog/orb-slam2/index.md","TranslationBaseName":"index","UniqueID":"3c61e1cd87a3e47e2bde84c6709ab76c"},"FuzzyWordCount":600,"GitInfo":{"hash":"e4d6dad6087ba976ce58db1543273945c4eb2785","abbreviatedHash":"e4d6dad","subject":"1. add slam-for-dummies page 2. add DBoW2 and AMCL pic","authorName":"nuhuo08","authorEmail":"845776955@qq.com","authorDate":"2020-01-26T15:20:07+08:00","commitDate":"2020-01-26T15:20:07+08:00"},"Kind":"page","Lastmod":"2020-01-26T15:20:07+08:00","Len":12549,"Name":"ORB-SLAM2","Permalink":"https://nuhuo08.github.io/orb-slam2/","Plain":"Tracking Initialization SearchForInitialization --\u0026gt; Initialize(RANSAC) --\u0026gt; GlobalBundleAdjustemnt --\u0026gt; ComputeSceneMedianDepth\nSearchForInitialization:\nGetFeaturesInArea --\u0026gt; DescriptorDistance --\u0026gt; ComputeThreeMaxima\nORB特征\nOriented FAST关键点：\n 比较像素点周围圆上的像素间亮度的差异 非极大值抑制，在一定区域内仅保留响应极大值的角点，避免太集中 对角点计算Harris响应值，仅保留前N个具有最大响应值的角点 构建金字塔，在金字塔每一层检测角点。实现尺度不变 灰度质心法，连接图像块的几何中心与质心。实现旋转不变  BRIEF描述子：\n 随机选点并比较灰度，组成128维的二进制数组 使用Hamming distance作为度量，即不同位数的个数  F矩阵\nhttps://zhuanlan.zhihu.com/p/61614421\n在求解F和H矩阵之前，应该首先进行特征点归一化，保证坐标均值为0，一阶绝对矩为1。(MVG P67，归一化才能消除坐标变换的影响)\n设\\(p1\\)，\\(p2\\)为像素坐标，可知：\n\\[ p_2 = K (RP + t) \\\\ p_1 = KP \\]\n从上述\\(p1\\)，\\(p2\\)的关系式出发，导出：\n\\[ (K^{-1} p_2)^T t^{\\wedge} K^{-1} p_2 = 0 = p_2^T K^{-T} t^{\\wedge} R K^{-1} p_1 = p_2^T F p_1 \\]\n一对匹配的像素点可以写1个方程，考虑到尺度等价性，使用八点法即可求解\\(F\\)矩阵。\nTODO: 由基础矩阵F分解出R和t\n多余的话\nopencv中，cv::findFundamentalMat()如果选择8点法，则是直接将所有点进行最小二乘计算，没有外点剔除功能。\nhttps://stackoverflow.com/questions/25251676/opencv-findfundamentalmat-very-unstable-and-sensitive/48394798\nH矩阵\n平面方程为：\n\\[ aX + bY + cZ + d = 0 \\\\ -\\frac{n^TP}{d} = -1 \\]\n依旧从\\(p1\\)，\\(p2\\)的关系式出发，导出：\n\\[ p_2 = K (RP + t \\cdot (-\\frac{n^TP}{d})) = K (R - \\frac{tn^T}{d}) K^{-1} p_1 = Hp_1 \\]\n一对匹配的像素点可以写2个方程，因此4对匹配特征点即可求解\\(H\\)矩阵。\nTODO: 由单应矩阵H恢复出R和t\nF与H的评分\n\n\\(\\Gamma\\) is defined equal to \\(T_H\\) so that both models score equally for the same d in their inlier region, again to make the process homogeneous.\n\\[ R_H=\\frac{S_H}{S_H+S_F} \\]\nselect the homography if \\(R_H0.45\\), which adequately captures the planar and low parallax cases. Otherwise, we select the fundamental matrix.\n三角化\nhttps://blog.csdn.net/weixin_43795395/article/details/93769148\nhttps://www.cnblogs.com/yepeichu/p/10792899.html\n已知匹配的像素点，及两帧图像的变换关系，则：\n\\[ x = PX \\\\ x' = P'X \\]\n根据\\(x^\\wedge PX = 0\\)性质，可得到如下方程：\n\\[ AX = \\begin{bmatrix} xp^{3T}-p^{1T} \\\\ yp^{3T}-p^{2T} \\\\ x'p'^{3T}-p'^{1T} \\\\ y'p'^{3T}-p'^{2T} \\end{bmatrix} X = 0 \\]\n对矩阵\\(A\\)进行SVD分解，可知：\n\\[ J(y) = \\min \\|Ax\\| = \\min \\|UDV^Tx\\| = \\min \\|DV^Tx\\| \\]\n由于对角阵\\(D\\)是矩阵\\(A\\)的奇异值从大到小降序排列而成，因此\\(J(y)\\) 的最小值在\\(D\\)矩阵奇异值最小的地方取到。可知：\n\\[ V^Tx = y = [0, 0, 0, 1]^T \\\\ x = Vy \\]\n于是，\\(x\\)的解就变成了正交矩阵\\(V\\)的最后一列的列向量。\n多余的话——解方程\nhttp://eigen.tuxfamily.org/dox/group__LeastSquares.html\n对于方程：\n\\[ Mx = b \\]\n可以使用最小二乘解\\(x = (M^T M)^{-1} M^T b\\)，或者利用QR分解\\(x = R^{-1} Q^T b\\)。\n将b移到左边，并设最后一个参数为1，可转换成如下方程：\n\\[ Mx = 0 \\]\n可以通过SVD分解，解对应于\\(M\\)最小特征值对应的特征向量。关于\\(M\\)与\\(M^T M\\)的SVD分解的关系， 可以参考“矩阵”一篇的笔记。\nTracking TrackWithMotionModel\nSearchByProjection --\u0026gt; PoseOptimization\nSearchByProjection:\nGetFeaturesInArea --\u0026gt; DescriptorDistance\nTrackWithReferenceKeyFrame\nSearchByBow --\u0026gt; PoseOptimization\nSearchByBow:\nFeatureVector --\u0026gt; DescriptorDistance --\u0026gt; ComputeThreeMaxima\nRelocalization\nSearchByBow --\u0026gt; EPnP(RANSAC) --\u0026gt; PoseOptimization --\u0026gt; SearchByProjection --\u0026gt; PoseOptimization\nEPnP:\nhttps://zhuanlan.zhihu.com/p/59070440\n 3D点的齐次坐标被表示为4个控制点齐次坐标的线性组合，然后将其作为已知量拿到相机坐标系下使用。 结合上一步，将相机坐标系下的空间点坐标，转换成4个控制点在摄像机坐标系下的坐标的线性组合，并结合对应的像素点坐标，建立方程，从而解算出控制点在摄像机坐标系下的坐标。 最后根据4个控制点，将所有的3D点在摄像机坐标系下的坐标恢复出来。接着采用ICP方法，求解出R和t。  ICP:\n 计算两组点的质心位置，然后计算每个点的去质心坐标  \\[ q_i = p_i - p \\\\ q_i' = p_i' - p' \\]\n求取R  \\[ W = \\sum_{i=1}^n q_i q_i'^T = U \\Sigma V^T \\\\ R = UV^T \\]\n求取t  \\[ t = p - R p' \\]\n\n题外话———未知对应关系的ICP：\n 根据距离最小寻找对应点 根据对应点，计算R和t 对点云进行转换，计算误差 重新寻找对应点，不断迭代，直至误差小于某一个值  属于EM算法的一种，待求变量为\\( [R | t] \\)，隐变量为点的对应关系。先固定第一个变量，优化另一个；再固定另一个，优化第一个变量。通过多次优化后，两个变量都达到最优值。\nUpdateLocalMap\nSearchByProjection --\u0026gt; PoseOptimization\nLocalMapping ComputeBow --\u0026gt; SearchForTriangulation --\u0026gt; LocalBA\nSearchForTriangulation:\nFeatureVector --\u0026gt; DescriptorDistance --\u0026gt; CheckDistEpipolarLine --\u0026gt; ComputeThreeMaxima\n关于优化中的卡方分布外点剔除\nhttps://zhuanlan.zhihu.com/p/58556978\n高斯白噪声的平方服从卡方分布，有几个观测量就代表几个自由度。\nLoopClosing TF-IDF TF: Term Frequency, 指某个特征在单幅图像中出现的频率。\n\\[ TF_i = \\frac{n_i}{n} \\]\nIDF: Inverse Document Frequency, 指单词在字典中出现的频率越高，则分类图像时区分度越高。\n\\[ IDF_i = \\log \\frac{n}{n_i} \\]\nComputeSim3 SearchByBow --\u0026gt; sim3(RANSAC) --\u0026gt; SearchBySim3 --\u0026gt; OptimizeSim3 --\u0026gt; SearchByProjection\n当两个姿态比较接近时，sim3求解不出有效值。这也是闭环成功后，后续很长一段时间里，不再进行闭环的原因。\nsim3:\n\nLoopClosing OptimizeEssentialGraph --\u0026gt; RunGlobalBundleAdjustment\nOptimization 点与位姿优化\n\\[ \\xi^* = \\arg \\min_\\xi \\frac{1}{2} \\sum_{i=1}^n {\\| u_i - \\frac{1}{s} K \\exp(\\xi^\\wedge) P_i \\|}_2^2 \\\\ P' = TP = RP + t \\\\ \\begin{bmatrix} u \\\\ v \\end{bmatrix} = \\begin{bmatrix}f_x \u00260 \u0026c_x \\\\ 0 \u0026f_y \u0026c_y\\end{bmatrix} \\begin{bmatrix}\\frac{X'}{Z'} \\\\ \\frac{Y'}{Z'}\\end{bmatrix} \\]\n回环（采用左扰动）\n实际ORB-SLAM的Pose Graph是采用的Sim3变换。此处仅推导SE(3)上的公式。\n\\[ e_{ij} = \\ln (T_{ij}^{-1} T_i^{-1} T_j)^\\vee \\\\ \\ln (T_{ij}^{-1} T_i^{-1} \\exp((-\\xi_i)^\\wedge) T_j)^\\vee \\\\ = \\ln (T_{ij}^{-1} T_i^{-1} T_j \\exp((-Ad(T_j^{-1})\\delta\\xi_i)^\\wedge))^\\vee \\\\ = \\ln (\\exp(e_{ij}^\\wedge) \\exp((-Ad(T_j^{-1})\\delta\\xi_i)^\\wedge))^\\vee \\\\ = \\mathcal{J}_r^{-1}(e_{ij}) (-Ad(T_j^{-1})\\delta\\xi_i) + e_{ij} \\\\ \\frac{ \\partial{e_{ij}} }{ \\partial{\\delta\\xi_i} } = -\\mathcal{J}_r^{-1}(e_{ij}) Ad(T_j^{-1}) \\]\n同理可得：\n\\[ \\frac{ \\partial{e_{ij}} }{ \\partial{\\delta\\xi_j} } = \\mathcal{J}_r^{-1}(e_{ij}) Ad(T_j^{-1}) \\]\n有以下近似关系：\n\\[ \\mathcal{J}_r^{-1}(e_{ij}) \\approx I + \\frac{1}{2} \\begin{bmatrix} \\phi_e^\\wedge \u0026\\rho_e^\\wedge \\\\ 0 \u0026\\phi_e^\\wedge \\end{bmatrix} \\]\nBowVector \u0026amp; FeatureVector      BowVector存储着叶子节点，信息最细微，仅用在DetectRelocalizationCandidates()函数中，用来选取备选帧。\nFeatureVector存储着倒数第4层的节点，信息比较粗糙，用在各种SearchBy*函数中，用来加速特征点的匹配。\nFeatureVector --\u0026gt; FClass 计算特征向量之间的距离，用于加速特征点匹配\nBowVector --\u0026gt; ScoringObject 计算单词之间的分数，用于匹配回环关键帧\nHKmeasStep --\u0026gt; createWords --\u0026gt; setNodeWeights\n先使用Kmeans++分为分层node；再将最后一层编码为word；最后每张图片对某个word计数最多加一次，计算权值\ng2o 采用se3表达参数；\n首先进行块分解，BlockSolver默认使用舒尔补消除变量;\n之后进行线性求解。其中LinearSolverDense直接进行Cholesky分解，LinearSolverEigen需要调用Eigen的稀疏Cholesky分解，且默认不reordering。因为在Schur之后，矩阵比较稠密，reordering影响不大；\nVeterx: oplusImpl\nEdge: ComputeError \u0026amp; linearizeOplus\nhttps://zhuanlan.zhihu.com/p/100522179\n","PublishDate":"2020-01-04T08:00:00+08:00","ReadingTime":3,"RelPermalink":"/orb-slam2/","Section":"blog","Stat":{"IsDir":false,"ModTime":"2020-01-26T13:47:47.923055278+08:00","Mode":436,"Name":"index.md","Size":9105},"Tags":null,"Title":"ORB-SLAM2","Type":"blog","Weight":0,"WordCount":537},{"Aliases":null,"File":{"BaseFileName":"index","ContentBaseName":"msckf","Dir":"blog/msckf/","Ext":"md","Lang":"en","LogicalName":"index.md","Path":"blog/msckf/index.md","TranslationBaseName":"index","UniqueID":"1b90e5694d8ae8fe6d5ab37e58dd41c5"},"FuzzyWordCount":700,"GitInfo":{"hash":"6fac72a1a190d9845ddd18a2ce3d39acf5c53ce8","abbreviatedHash":"6fac72a","subject":"add msckf page","authorName":"nuhuo08","authorEmail":"845776955@qq.com","authorDate":"2020-01-25T23:23:21+08:00","commitDate":"2020-01-25T23:23:21+08:00"},"Kind":"page","Lastmod":"2020-01-25T23:23:21+08:00","Len":6610,"Name":"MSCKF","Permalink":"https://nuhuo08.github.io/msckf/","Plain":"QR分解 \\[ A_{2m \\times 3} = Q_{2m \\times 2m}R_{2m \\times 3} = \\begin{bmatrix} B_{2m \\times 3} \u0026C_{2m \\times (2m - 3)} \\end{bmatrix} \\begin{bmatrix} D_{3 \\times 3} \\\\ 0_{(2m - 3) \\times 3} \\end{bmatrix} \\]\n其中，\\(Q\\) 为正交矩阵，每一列代表一个基向量，与除了自身以外的其他基向量的点积都为0。Where \\(B\\) and \\(C\\) are unitary matrices whose columns form bases for the range and nullspace of \\(A\\).\n\\[ {C^T}_{(2m-3) * 2m} A_{2m \\times 3} = \\begin{bmatrix} 0_{(2m-3) \\times 3} \u0026I_{(2m-3) \\times (2m - 3)} \\end{bmatrix} \\begin{bmatrix} D_{3 \\times 3} \\\\ 0_{(2m - 3) \\times 3} \\end{bmatrix} = 0_{(2m-3) \\times 3} \\]\n\\(C\\)称为\\(A\\)的左零空间，当左乘\\(C^T\\)以后，整个矩阵都变为0。\n\\[ {B^T}_{3 * 2m} A_{2m \\times 3} = \\begin{bmatrix} I_{3 \\times 3} \u00260_{3 \\times (2m - 3)} \\end{bmatrix} \\begin{bmatrix} D_{3 \\times 3} \\\\ 0_{(2m - 3) \\times 3} \\end{bmatrix} = D_{3 \\times 3} \\]\n当左乘\\(B^T\\)以后，仅重要信息被保留下来为\\(D\\)\n状态量 当前IMU状态\\(15\\)维，加上滑窗内\\(N\\)帧图像，每个相机位姿6维，共计\\(15+6N\\)\n\\[ {\\hat{X}}_k = \\begin{bmatrix} ^I_G\\bar{q} \\\\ {b_g} \\\\ {^Gv_I} \\\\ {b_a} \\\\ {^Gp_I} \\\\ {^{C_1}_G\\hat{\\bar{q}}} \\\\ ^G\\hat{p}_{C_1} \\\\ \\vdots \\\\ {^{C_N}_G\\hat{\\bar{q}}} \\\\ ^G\\hat{p}_{C_N} \\end{bmatrix} \\]\n状态增广 当增加第\\(N+1\\)个新的相机位姿时，状态向量需要增广。\n\\[ \\begin{bmatrix} ^I_G\\bar{q}^T \\\\ {b_g}^T \\\\ {^Gv_I}^T \\\\ {b_a}^T \\\\ {^Gp_I}^T \\\\ {^{C_1}_G\\hat{\\bar{q}}}^T \\\\ ^G\\hat{p}_{C_1}^T \\\\ \\vdots \\\\ {^{C_N}_G\\hat{\\bar{q}}}^T \\\\ ^G\\hat{p}_{C_N}^T \\\\ {^{C_{N+1}}_G\\hat{\\bar{q}}}^T \\\\ ^G\\hat{p}_{C_{N+1}}^T \\end{bmatrix} = \\underbrace{\\begin{bmatrix} I \u00260 \u00260 \u00260 \u00260 \u00260 \u00260 \u0026\\cdots \u00260 \u00260\\\\ 0 \u0026I \u00260 \u00260 \u00260 \u00260 \u00260 \u0026\\cdots \u00260 \u00260\\\\ 0 \u00260 \u0026I \u00260 \u00260 \u00260 \u00260 \u0026\\cdots \u00260 \u00260\\\\ 0 \u00260 \u00260 \u0026I \u00260 \u00260 \u00260 \u0026\\cdots \u00260 \u00260\\\\ 0 \u00260 \u00260 \u00260 \u0026I \u00260 \u00260 \u0026\\cdots \u00260 \u00260\\\\ 0 \u00260 \u00260 \u00260 \u00260 \u0026I \u00260 \u0026\\cdots \u00260 \u00260\\\\ 0 \u00260 \u00260 \u00260 \u00260 \u00260 \u0026I \u0026\\cdots \u00260 \u00260\\\\ \u0026 \u0026 \u0026 \u0026\\vdots \\\\ 0 \u00260 \u00260 \u00260 \u00260 \u00260 \u00260 \u0026\\cdots \u0026I \u00260\\\\ 0 \u00260 \u00260 \u00260 \u00260 \u00260 \u00260 \u0026\\cdots \u00260 \u0026I\\\\ C(^C_I\\bar{q}) \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026\\cdots \u00260 \u00260 \\\\ \\lfloor C_{\\hat{q}}^T p_C \\times \\rfloor \u00260 \u00260 \u0026 0 \u0026I \u00260 \u00260 \u0026\\cdots \u00260 \u00260 \\end{bmatrix}}_A * \\begin{bmatrix} ^I_G\\bar{q}^T \\\\ {b_g}^T \\\\ {^Gv_I}^T \\\\ {b_a}^T \\\\ {^Gp_I}^T \\\\ {^{C_1}_G\\hat{\\bar{q}}}^T \\\\ ^G\\hat{p}_{C_1}^T \\\\ \\vdots \\\\ {^{C_N}_G\\hat{\\bar{q}}}^T \\\\ ^G\\hat{p}_{C_N}^T \\end{bmatrix} \\]\n对应的协方差矩阵也需要进行传播。 \\( P_{k|k} = A P_{k|k} A^T \\)\n多余的话\n关于协方差增广，可以与 slam for dummies 进行对比学习。在该文中，新的特征点与当前的机器人位姿、激光观测量都有关系，其协方差为：\n\\[ P^{N+1 \\ N+1} = J_{xr} P J_{xr}^T + J_z R J_z^T \\]\n三角化点 将相机坐标当作已知值，优化共同观测到的某个特征点坐标\n\\[ h = \\begin{pmatrix} h_0 \\\\ h_1 \\\\ h_2 \\end{pmatrix} = R \\begin{pmatrix} \\frac{X}{Z} \\\\ \\frac{Y}{Z} \\\\ 1 \\end{pmatrix} + \\frac{1}{Z} t = R \\begin{pmatrix} \\alpha \\\\ \\beta \\\\ 1 \\end{pmatrix} + \\rho t \\\\ z = \\begin{pmatrix} \\frac{h_0}{h_2} \\\\ \\frac{h_1}{h_2} \\end{pmatrix} \\]\n由此得到雅可比矩阵：\n\\[ J = \\frac{\\partial e_i}{\\partial(\\alpha, \\beta, \\rho)} = -\\frac{\\partial z}{\\partial h} \\begin{bmatrix} \\frac{\\partial h}{\\partial \\alpha} \u0026 \\frac{\\partial h}{\\partial \\beta} \u0026 \\frac{\\partial h}{\\partial \\rho} \\end{bmatrix} \\\\ = -\\begin{bmatrix} \\frac{1}{h_2} \u0026 0 \u0026 -\\frac{h_0}{h_2^2} \\\\ 0 \u0026 \\frac{1}{h_2} \u0026 -\\frac{h_1}{h_2^2} \\end{bmatrix} \\begin{bmatrix} R\\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} \u0026 R\\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix} \u0026 t \\end{bmatrix} \\\\ \\]\n观测模型 特征点坐标是根据相机坐标计算出来的，而观测量误差同时与特征点和相机的坐标误差相关。\n\\[ ^{C_i} p_j = \\begin{bmatrix} ^{C_i} \\hat X_j \\\\ ^{C_i} \\hat Y_j \\\\ ^{C_i} \\hat Z_j \\end{bmatrix} =C(^{C_i} _G \\hat q)(^G \\hat p _{j} - ^G \\hat p _{C_i}) \\\\ \\hat z_i^{(j)} = \\begin{bmatrix} \\frac{^{C_i} \\hat X_j}{^{C_i} \\hat Z_j} \\\\ \\frac{^{C_i} \\hat Y_j}{^{C_i} \\hat Z_j} \\end{bmatrix} \\]\n对相机位姿、特征点位置的误差求雅可比：\n\\[ r_i^{(j)} \\approx \\frac{\\partial z_i^{(j)}}{\\partial ^{C_i} p_j} \\frac{\\partial ^{C_i} p_j}{\\partial X_{C_i}} \\tilde X + \\frac{\\partial z_i^{(j)}}{\\partial ^{C_i} p_j} \\frac{\\partial ^{C_i} p_j}{\\partial ^Gp_j} {^G}{\\tilde{p}_{j}} \\\\ = \\begin{bmatrix} \\frac{1}{^{C_i} \\hat Z_j} \u0026 0 \u0026 -\\frac{^{C_i} \\hat X_j}{^{C_i} \\hat Z_j} \\\\ 0 \u0026 \\frac{1}{^{C_i} \\hat Z_j} \u0026 -\\frac{^{C_i} \\hat Y_j}{^{C_i} \\hat Z_j} \\end{bmatrix} \\begin{bmatrix} \\lfloor {^{C_i} \\hat p _{j}}_\\times \\rfloor \u0026 -C(^{C_i} _G \\hat q) \\end{bmatrix} \\tilde X + \\begin{bmatrix} \\frac{1}{^{C_i} \\hat Z_j} \u0026 0 \u0026 -\\frac{^{C_i} \\hat X_j}{^{C_i} \\hat Z_j} \\\\ 0 \u0026 \\frac{1}{^{C_i} \\hat Z_j} \u0026 -\\frac{^{C_i} \\hat Y_j}{^{C_i} \\hat Z_j} \\end{bmatrix} \\begin{bmatrix} C(^{C_i} _G \\hat q) \\end{bmatrix} {^G}{\\tilde{p}_{j}} \\]\n精华：将观测到该特征点的多个相机观测值累积到一起形成大型矩阵，并将观测量误差投影到相机坐标误差雅可比矩阵的左零空间中，消去特征点坐标误差。由此，观测量误差仅与相机坐标误差相关！\n\\[ r^{(j)} \\simeq H_X^{(j)} \\tilde{X} + H_f^{(j)} {^G}{\\tilde{p}_{f_j}} + n^{(j)} \\\\ r_o^{(j)} = A^T r^{(j)} \\simeq A^T H_X^{(j)} \\tilde{X} + A^Tn^{(j)} = H_o^{(j)} \\tilde{X} ^{(j)} + n_o^{(j)} \\]\n滤波更新 使用QR分解，仅保留观测值中的有效信息。\n\\[ r_o = \\begin{bmatrix} Q_1 \u0026Q_2 \\end{bmatrix} \\begin{bmatrix} T_H \\\\ 0 \\end{bmatrix} \\tilde{X} + n_o \\\\ r_n = Q_1^Tr_o = T_H \\tilde{X} + n_n \\]\n","PublishDate":"2020-01-03T08:00:00+08:00","ReadingTime":4,"RelPermalink":"/msckf/","Section":"blog","Stat":{"IsDir":false,"ModTime":"2020-01-25T22:38:42.035179912+08:00","Mode":436,"Name":"index.md","Size":5665},"Tags":null,"Title":"MSCKF","Type":"blog","Weight":0,"WordCount":669},{"Aliases":null,"File":{"BaseFileName":"index","ContentBaseName":"amcl","Dir":"blog/amcl/","Ext":"md","Lang":"en","LogicalName":"index.md","Path":"blog/amcl/index.md","TranslationBaseName":"index","UniqueID":"71cc57c5539d74bcf374be08f7f36f11"},"FuzzyWordCount":200,"GitInfo":{"hash":"e4d6dad6087ba976ce58db1543273945c4eb2785","abbreviatedHash":"e4d6dad","subject":"1. add slam-for-dummies page 2. add DBoW2 and AMCL pic","authorName":"nuhuo08","authorEmail":"845776955@qq.com","authorDate":"2020-01-26T15:20:07+08:00","commitDate":"2020-01-26T15:20:07+08:00"},"Kind":"page","Lastmod":"2020-01-26T15:20:07+08:00","Len":6310,"Name":"AMCL","Permalink":"https://nuhuo08.github.io/amcl/","Plain":"ROS-AMCL      粒子聚类 对外输出的机器人状态不应该是某一个最好的粒子，因为很有可能某些粒子的值都非常接近，可能会引起频繁的粒子切换，导致输出的结果来回跳变。\n基于此考虑， 应该对相似的粒子进行聚类。将最好的那一簇粒子的统计状态作为输出的机器人状态。\nKD-Tree 当涉及到距离查找时，作为算法工程师，我们应该首先想到KD-Tree。树的叶子节点是每一个粒子，而非叶子节点则保存的是该节点的分叉判断的标准，小于此分叉判断标准的在左边，大于此分叉标准的在右边。\n查询的基本思路：首先通过二叉树搜索（比较待查询节点和分裂节点的分裂维的值，小于等于就进入左子树分支，等于就进入右子树分支直到叶子结点），顺着“搜索路径”很快能找到最近邻的近似点，也就是与待查询点处于同一个子空间的叶子结点；然后再回溯搜索路径，并判断搜索路径上的结点的其他子结点空间中是否可能有距离查询点更近的数据点，如果有可能，则需要跳到其他子结点空间中去搜索（将其他子结点加入到搜索路径）。重复这个过程直到搜索路径为空。\n     聚类 循环遍历每一个叶子节点，在叶子节点周围的 +-1 范围内的粒子都归为一类。例如在AMCL中，每个粒子周围27个粒子若有相连的，就将它们全部连成一片，形成一簇粒子。\n粒子滤波改进 为了防止机器人被绑架，出现粒子收敛于某一错误的地方，需要进行粒子滤波的改良。\n粒子注入 我们来考虑如下的式子：\n\\[ x_1 = x + 0.1(y-x) \\\\[2mm] x_2 = x + 0.9(y-x) \\]\n对于上面两个式子，展开以后我们可以发现：\\(x_1\\) 主要受到 \\(x\\) 的影响，而 \\(x_2\\) 主要受到 \\(y\\) 的影响。若粒子收敛于正确的状态，则 \\(y\\) 是准确的，\\(x_2\\) 将会比 \\(x_1\\) 更大，此时不需要注入粒子。若粒子收敛于错误的地方，则 \\(y\\) 不准确，此时 \\(x_1\\) 受到 \\(y\\) 的影响较小，\\(x_1\\) 更准确，此时便需要注入粒子。\n而这正是AMCL里面slow和fast参数产生的效果。\nKLD自适应 KLD的计算属于数理统计的知识，可参考论文1。这里进行直观的解释。\n例如，某一粒子权值很大。当我们进行100次采样，可能都采样到的是同一个粒子，此时粒子的个数始终保持为1。而KLD计算出来的需要采样的次数，是粒子个数的函数。因此，当粒子数保持为1时，KLD计算出来的次数为某一定值，而采样次数持续在增加，到某一时间点，便超过了需要的采样次数。\n而当粒子权值都接近时，假设我们采样了100次，每次采样出来的粒子都不同，此时粒子的个数一直增长到100。此时的KLD也随着粒子的个数增长到一个比较大的值。采样的次数虽然持续增加，但是始终超过不了KDL计算出来的次数。此种情况下采样仍将继续。\n距离计算 计算每个粒子的权重时，我们需要计算观测到的障碍物与地图中的障碍物的距离差异。差异越大，权值越小。当某次观测的障碍物全部与地图上的障碍物匹配上了，则差异为0，权值极大。因此，在地图的初始阶段，我们需要计算地图上任一点位置到最近障碍物的距离。这就是似然场模型。\n直接计算 遍历每一个点，计算每一个点到每个障碍物的距离并取最小值。此方法进行了重复计算，效率较低。\n高效算法 从障碍物出发，向外膨胀一个单位。当所有障碍物膨胀完以后，从膨胀出来的地方出发，继续向外膨胀一个单位。此方法没有冗余计算，且实现的代码简洁。\nAMCL参数解读 min_particles / max_particles / kld_err / kld_z : 用来限制粒子数量\nupdate_min_d / update_min_a / resample_interval : 限制冲采样条件\nrecovery_alpha_slow / recovery_alpha_fast : 动态调整粒子数量\ninitial_pose_xya / initial_cov_xxyyaa : 初始位置及其协方差\nodom_alpha1234 : 里程计运动模型误差系数\n参考资料 http://www.robots.ox.ac.uk/~cvrg/hilary2005/adaptive.pdf\nhttps://blog.csdn.net/Mark_SLAM/article/details/81266527\nhttps://zhuanlan.zhihu.com/p/28137335\nhttps://zhuanlan.zhihu.com/p/59411695\nhttps://zhuanlan.zhihu.com/p/59663340\nhttps://zhuanlan.zhihu.com/p/61908381\nudacity robot\ngithub particle filter\n","PublishDate":"2020-01-02T08:00:00+08:00","ReadingTime":1,"RelPermalink":"/amcl/","Section":"blog","Stat":{"IsDir":false,"ModTime":"2020-01-27T10:02:15.823267176+08:00","Mode":436,"Name":"index.md","Size":4812},"Tags":null,"Title":"AMCL","Type":"blog","Weight":0,"WordCount":102},{"Aliases":null,"File":{"BaseFileName":"index","ContentBaseName":"hugo-website","Dir":"blog/hugo-website/","Ext":"md","Lang":"en","LogicalName":"index.md","Path":"blog/hugo-website/index.md","TranslationBaseName":"index","UniqueID":"08d10ed3d87b41b34d3e307006faa647"},"FuzzyWordCount":200,"GitInfo":{"hash":"d5bbb7eafe717b8f0f0ca5f44d2adc94fe2acb7f","abbreviatedHash":"d5bbb7e","subject":"1. add about page 2. add hugo-website page 3. add homepage","authorName":"nuhuo08","authorEmail":"845776955@qq.com","authorDate":"2020-01-25T14:45:57+08:00","commitDate":"2020-01-25T14:45:57+08:00"},"Kind":"page","Lastmod":"2020-01-25T14:45:57+08:00","Len":2772,"Name":"Hugo Website","Permalink":"https://nuhuo08.github.io/hugo-website/","Plain":"申请Github账号 Github私人博客仓库 新建Hugo_Blogs仓库，此仓库保存个人的markdown源文件等。可设置为private仓库。\nGithub Pages 新建username.github.io的仓库，此仓库保存Hugo生成出来的html文件等。https://username.github.io/即为最终的个人博客地址。必须设置为public仓库。\n安装Hugo Hugo Tutorial\nBinary Package\n新建私人博客文件夹 创建网站文件夹 新建网站文件夹，并用hugo生成基本网站文件\nmkdir MyWebsite \u0026amp;\u0026amp; cd MyWebsite hugo new site . 链接Github私人博客仓库 添加git源，保存私人的markdown源文件\ngit init git remote add origin https://github.com/username/Hugo_Blogs.git 添加并使用新的theme git submodule add https://github.com/nuhuo08/uswds-hugo-theme.git themes/uswds-hugo-theme git submodule update --remote --merge cp themes/uswds-hugo-theme/exampleSite/config.yaml . 编辑网页 链接Github Pages 为了能够使用git submodule，需要先在仓库里添加点文件，之后再把它删掉。\nmkdir public \u0026amp;\u0026amp; cd public \u0026amp;\u0026amp; touch abc git remote add origin https://github.com/username/username.github.io.git git add . git commit -m \u0026quot;abc\u0026quot; git push orign master cd .. \u0026amp;\u0026amp; rm -rf public 然后再添加submodule，继续进行下一步。\ncd MyWebsite git submodule add https://github.com/username/username.github.io.git public 创建第一个网页 mkdir content/blog vi content/blog/my-first-blog.md 生成并本机预览网页 hugo hugo server -D 将改动上传至2个Git仓库 发布网页 hugo # if using a theme, replace with `hugo -t \u0026lt;YOURTHEME\u0026gt;` cd MyWebsite/public git add . git commit git push origin master 保存私人博客源文件 cd MyWebsite git add . git commit git push origin master ","PublishDate":"2020-01-01T08:00:00+08:00","ReadingTime":1,"RelPermalink":"/hugo-website/","Section":"blog","Stat":{"IsDir":false,"ModTime":"2020-01-27T10:02:32.067216942+08:00","Mode":436,"Name":"index.md","Size":2051},"Tags":null,"Title":"Hugo Website","Type":"blog","Weight":0,"WordCount":135},{"Aliases":null,"File":{"BaseFileName":"index","ContentBaseName":"about","Dir":"about/","Ext":"md","Lang":"en","LogicalName":"index.md","Path":"about/index.md","TranslationBaseName":"index","UniqueID":"8576ec274c98b3831668a172fa632d80"},"FuzzyWordCount":100,"GitInfo":{"hash":"18e92a3feff54bd6afcfac3ff7e4ee50992f8c6d","abbreviatedHash":"18e92a3","subject":"add amcl page","authorName":"nuhuo08","authorEmail":"845776955@qq.com","authorDate":"2020-01-25T18:24:08+08:00","commitDate":"2020-01-25T18:24:08+08:00"},"Kind":"page","Lastmod":"2020-01-25T18:24:08+08:00","Len":850,"Name":"About","Permalink":"https://nuhuo08.github.io/about/","Plain":"转眼已2020年，自己马上也要30了。三十而立，却一直没有可见的成绩。见过很多优秀的人，对自己的无所作为愈加愤怒。\n昨天晚上重读中央文献出版社的《毛泽东传》，看到这样一句话：\n\r\r毛泽东第一次进入中国共产党的领导核心，这时他三十岁，刚好是“而立”之年。\r\r慢慢的开始接受自己的平凡。不过，虽身不能至，然心向往之。从今天开始整理自己的私人网站，总结以前学过的各种知识， 记录自己的生活点滴与感悟，权当作一点点慰藉吧。\n\r\rTo learn, read; To know, write; To master, teach.\r\r做一点事，发一点光，写一点博客，找一点意义。\n","PublishDate":"2020-01-01T00:00:00Z","ReadingTime":1,"RelPermalink":"/about/","Section":"","Stat":{"IsDir":false,"ModTime":"2020-01-25T18:17:10.045246994+08:00","Mode":436,"Name":"index.md","Size":855},"Tags":null,"Title":"About","Type":"page","Weight":0,"WordCount":15}],"site":{"BaseURL":"https://nuhuo08.github.io","IsMultiLingual":false,"IsServer":false,"Language":{"Lang":"en","LanguageName":"","Title":"","Weight":0,"Disabled":false,"ContentDir":"","Cfg":{}},"LastChange":"2020-01-26T15:20:07+08:00","RSSLink":"https://nuhuo08.github.io/index.xml","Title":"XiaoWu"}}
